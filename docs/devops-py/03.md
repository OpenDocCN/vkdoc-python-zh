# 三、交互式使用

Python 通常用于探索性编程。通常，最终的结果不是程序，而是一个问题的答案。对科学家来说，问题可能是“医学干预起作用的可能性有多大？”对于排除计算机故障的人来说，问题可能是“哪个日志文件有我需要的消息？”

然而，不管这个问题是什么，Python 通常是回答这个问题的强大工具。更重要的是，在探索性编程中，我们期望遇到更多的问题，基于答案。

Python 中的交互模型来自最初的 Lisp 环境的“读取-评估-打印循环”(简称 REPL)。该环境读取一个 Python 表达式，在内存中持久化的环境中对其求值，打印结果，然后循环返回。

Python 本地的 REPL 环境很受欢迎，因为它是内置的。然而，一些第三方 REPL 工具甚至更强大，可以做本地工具不能或不愿做的事情。这些工具提供了一种与操作系统交互的强大方式，探索和塑造，直到达到期望的状态。

## 3.1 本机控制台

不带任何参数启动`python`将打开“交互式控制台”。使用`pyenv`或虚拟环境来确保 Python 版本是最新的是一个好主意。

无需安装任何其他东西就能立即获得交互式控制台，这是 Python 适合于探索性编程的一个原因。我们可以立即提问。

这些问题可能很琐碎:

```py
>>> 2 + 2
4

```

它们可用于计算海湾地区的销售税:

```py
>>> rate = 9.25
>>> price = 5.99
>>> after_tax = price ∗ (1 + rate / 100.)
>>> after_tax
6.544075

```

或者他们可以回答关于操作环境的重要问题:

```py
>>> import os

>>> os.path.isfile(os.path.expanduser("~/.bashrc"))
True

```

使用没有`readline`的 Python 原生控制台是不愉快的。用`readline`支持重新构建 Python 是个好主意，这样原生控制台将会很有用。如果这不是一个选项，建议使用备用控制台之一。例如，带有特定选项的本地构建的 Python 可能不包括`readline`，并且向整个团队重新分发新的 Python 可能会有问题。

如果安装了 readline 支持，Python 将使用它来支持行编辑和历史。也可以使用`readline.write_history_file`保存历史记录。这通常是在使用控制台一段时间后，为了参考已经完成的工作，或者将任何想法复制到更永久的形式中。

当使用控制台时，`_`变量将计算最后一个表达式语句的值。请注意，异常、非表达式语句和 stat 语句是计算结果为`None`的表达式，它们不会改变`_`的值。这在交互式会话中很有用，只有在看到值的表示后，我们才意识到我们需要它作为一个对象。

```py
>>> import requests

>>> requests.get("http://en.wikipedia.org")
<Response [200]>
>>> a=_
>>> a.text[:50]
'<!DOCTYPE html>\n<html class="client-nojs" lang="en'

```

只有在使用了`.get`函数之后，我们才意识到我们真正想要的是文本。幸运的是，`Response`对象保存在变量`_`中。我们立即将变量的值放入`a`， *_* 被快速替换。我们一评估`a.text[:50]`，`_`现在就是一个 50 个字符的字符串。如果我们没有将`_`保存在变量中，除了前 50 个字符之外的所有字符都将丢失。

注意，每个好的 Python REPL 都遵守这个`_`约定，因此“将返回值保存在单字母变量中”的技巧在进行探索时通常很有用。

## 3.2 代码模块

模块允许我们运行自己的交互循环。这种方法有用的一个例子是，当运行带有特殊标志的命令时，我们可以在特定的点进入提示符状态。这允许我们在以某种方式设置好事情之后，拥有一个 REPL 环境。这适用于解释器内部，用有用的东西建立名称空间；在外部环境中，可能初始化文件或设置外部服务。

`code`的最高级用法是`interact`函数。

```py
>>> import code

>>> code.interact(banner="Welcome to the special interpreter",
...               local=dict(special=[1, 2, 3]))
Welcome to the special interpreter
>>> special
[1, 2, 3]
>>> ^D
now exiting InteractiveConsole...
>>> special
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'special' is not defined

```

这显示了一个使用变量`special`运行 REPL 循环的例子，该变量设置为一个短列表。

对于`code`的最底层使用，如果你想自己拥有 UI，`code.compile_command(source, [filename="<input>"], symbol="single")`会返回一个 code 对象(可以传递给`exec`)，如果命令不完整则返回`None`，如果命令有问题则抛出`SyntaxError`、`OverflowError`或`ValueError`。

`symbol`参数应该总是为`"single`。`"`例外情况是，如果提示用户输入将计算为表达式的代码(例如，如果值将由底层系统使用)。在这种情况下，`symbol`应该设置为`"eval`。`"`

这允许我们自己管理与用户的交互。它可以与 UI 或远程网络接口集成，以允许在任何环境中进行交互。

## 3.3 ptpython

`ptpython`工具是“prompt toolkit Python”的缩写，是内置 REPL 的替代工具。它使用 prompt toolkit 进行控制台交互，而不是使用`readline`。

它的主要优点是安装简单。一个简单的`pip install ptpython`在虚拟环境中，不考虑 readline 构建问题，一个高质量的 Python REPL 出现了。

`ptpython`支持完成建议、多行编辑和语法高亮显示。

启动时，它将读取`~/.ptpython/config.py`。这意味着可以以任意方式在本地定制 ptpython。配置的方法是实现一个函数`configure`，它接受一个对象(类型为`PythonRepl`)并对其进行变异。

有很多种可能性，遗憾的是唯一真正的文档是源代码。相关参考号`__init__`为`ptpython.python_input.PythonInput`。注意，`config.py`实际上是一个任意的 Python 文件。因此，如果你想在内部发布修改，可以发布一个本地的 PyPI 包，让人们从中导入一个`configure`函数。

## 3.4 IPython

IPython 也是 Jupyter 的基础，这将在后面介绍，它是一个交互式环境，其根源在于科学计算社区。IPython 是一个交互式命令提示符，类似于`ptpython`工具或 Python 的原生 REPL。

然而，它旨在提供一个复杂的环境。它做的事情之一是对解释器的每个输入和输出进行编号。以后能够参考这些数字是很有用的。IPython 将所有输入放入`In`数组，输出放入`Out`数组。这允许很好的对称:例如，如果 IPython 说`In[4]`，这是如何访问该值。

```py
In [1]: print("hello")
hello

In [2]: In[1]
Out[2]: 'print("hello")'

In [3]: 5 + 4.0
Out[3]: 9.0

In [4]: Out[3] == 9.0
Out[4]: True

```

它还支持现成的制表符补全。IPython 使用自己的完成和`jedi`库进行静态完成。

它还支持内置帮助。键入`var_name?`将试图找到变量中对象的最佳上下文相关帮助，并显示它。这适用于函数、类、内置对象等等。

```py
In [1]: list?
Init signature: list(self, /, ∗args, ∗∗kwargs)
Docstring:
list() -> new empty list
list(iterable) -> new list initialized from iterable's items
Type:           type

```

IPython 还支持一种叫做“magic”的东西，在一行前面加上`%`将执行一个神奇的功能。例如，`%run`将在当前名称空间内运行一个 Python 脚本。又如，`%edit`将推出一个编辑器。如果在使用过程中，语句需要更复杂的编辑，这将非常有用。

此外，在一行前面加上！将运行系统命令。利用这一点的一个有用方法是`!pip install something`。这就是为什么在用于交互式开发的虚拟环境中安装 IPython 是有用的。

IPython 可以通过多种方式进行定制。在交互式会话中，`%config`魔术命令可用于更改任何选项。例如，`%config InteractiveShell.autocall = True`将设置 autocall 选项，这意味着调用可调用的表达式，即使没有括号。对于任何只影响启动的选项来说，这都是没有意义的。我们可以使用命令行更改这些选项以及任何其他选项。例如，`ipython --InteractiveShell.autocall=True`，将启动一个自动调用解释器。

如果我们希望自定义逻辑决定配置，我们可以从专门的 Python 脚本运行 IPython。

```py
from traitlets import config

import IPython

my_config = config.Config()
my_config.InteractiveShell.autocall = True

IPython.start_ipython(config=my_config)

```

如果我们将它打包在一个专用的 Python 包中，我们可以使用 PyPI 或私有的包存储库将它分发给一个团队。这允许开发团队拥有同质的定制 IPython 配置。

最后，配置也可以编码在概要文件中，默认情况下，概要文件是位于`~/.ipython`下的 Python 片段。概要文件目录可以通过一个显式的命令行参数`--ipython-dir`或一个环境变量`IPYTHONDIR`来修改。

## 3.5 Jupyter Lab

Jupyter 是一个使用基于 web 的交互来允许复杂的探索性编程的项目。它并不局限于 Python，尽管它确实起源于 Python。这个名字代表“Julia/Python/R”，这三种语言在探索性编程中最受欢迎，尤其是在数据科学中。

Jupyter Lab 是 Jupyter 的最新进化，最初基于 IPython。它现在拥有一个全功能的网络界面和一种远程编辑文件的方式。Jupyter 的主要用户往往是科学家。他们利用查看结果如何得出的能力来增加可重复性和同行评审。

再现性和同行评审对 DevOps 工作也很重要。例如，显示导致决定重启哪个主机列表的步骤的能力是非常有用的，以便在环境发生变化时可以重新生成该列表。将笔记本附加到事后分析有助于了解发生了什么，以及如何在将来避免问题或更有效地从问题中恢复，笔记本详细描述了停机期间采取的步骤以及这些步骤的输出。

这里需要注意的是，笔记本是*而不是*可审计性工具:它们可以不按顺序执行，并且可以修改和重新执行程序块。然而，如果使用得当，它们可以让我们记录下做过的事情。

Jupyter 允许真正的探索性编程。这对科学家来说很有用，他们可能事先不了解问题的真实范围。

这里需要注意的是，笔记本是*而不是*可审计性工具:它们可以不按顺序执行，并且可以修改和重新执行程序块。然而，如果使用得当，它们可以让我们记录下做过的事情。这对于面临复杂系统的系统集成商也很有用，因为在探索之前很难预测问题出在哪里。

在虚拟环境中安装 Jupyter Lab 是一件简单的事情。当启动`jupyter lab`时，默认情况下，它将在从`8888`开始的开放端口上启动一个 web 服务器，并尝试启动一个 web 浏览器来观看它。如果在一个“太有趣”的环境中工作(例如，默认的 web 浏览器没有正确配置)，标准输出将包含一个预先授权的 URL 来访问服务器。如果所有其他方法都失败，可以在 web 浏览器中手动输入 URL 后，将打印到标准输出的令牌复制粘贴到浏览器中。还可以使用`jupyter notebook`列表访问令牌，该列表将列出所有当前正在运行的服务器。

一旦进入 Jupyter 实验室，我们可以发射五个东西:

*   安慰

*   末端的

*   文字编辑器

*   笔记本

*   电子表格编辑器

`Console`是 IPython 的一个基于 web 的接口。之前关于 IPython 的所有内容(例如，`In`和`Out`数组)。`Terminal`是浏览器中成熟的终端模拟器。这对于 VPN 内部的远程终端很有用:它所需要的只是一个开放的 web 端口，它也可以用 web 端口的常规保护方式来保护:TLS、客户端证书等等。文本编辑器对于编辑远程文件很有用。这是运行远程 shell 的一种替代方式，其中有一个编辑器，比如`vi`。它的优点是避免了 UI 延迟，同时仍然具有完整的文件编辑功能。

不过，最有趣的是笔记本:事实上，很多会议除了笔记本什么都不用。笔记本是记录会话的 JSON 文件。随着会话的展开，Jupyter 将保存笔记本的“快照”以及最新版本。笔记本是由一系列细胞组成的。两种最流行的单元格类型是“代码”和“降价”“代码”单元类型将包含一个 Python 代码片段。它将在会话的名称空间的上下文中执行它。名称空间从一个单元执行到另一个单元执行是持久的，对应于一个“内核”运行。内核使用自定义协议接受单元内容，将它们解释为 Python，执行它们，并返回代码片段返回的内容和输出。

在启动 Jupyter 服务器时，默认情况下，它将使用本地 IPython 内核作为唯一可能的内核。这意味着，举例来说，服务器将只能使用相同的 Python 版本和相同的包集。但是，可以将不同环境中的内核连接到该服务器。唯一的要求是环境已经安装了`ipykernel`包。从环境中，运行:

```py
python -m ipykernel install \
       --name my-special-env \
       --display-name "My Env"
       --prefix=$DIRECTORY

```

然后，在 Jupyter 服务器环境中，运行:

```py
jupyter kernelspec install $DIRECTORY/jupyter/kernels/my-special-env

```

这将导致该环境中的 Jupyter 服务器支持来自特殊环境的内核。这允许运行一个半永久性的 Jupyter 服务器，并连接来自任何“有趣”环境的内核:安装特定的模块，运行特定版本的 Python，或任何其他差异。替代内核的另一个用途是替代语言，这里不详细介绍。Julia 和 R 内核是上游支持的，但是许多语言都有第三方内核——甚至`bash`！

Jupyter 支持来自 IPython 的所有魔法命令。特别有用的是在虚拟环境中安装新软件包的`!pip install ...`命令。特别是如果小心谨慎，并安装精确的依赖关系，这使得笔记本成为如何以可重复的方式实现结果的高质量文档。

由于 Jupyter 是内核的一个间接层，我们可以直接从 Jupyter 重启内核。这意味着整个 Python 进程重新启动，所有内存中的结果都消失了。我们可以以任何顺序重新执行单元格，但有一种单键方式可以按顺序执行所有单元格。重新启动内核，并按顺序执行所有单元，这是“测试”笔记本工作条件的一种很好的方式——当然，对外部世界的任何影响都不会被重置。

Jupyter 笔记本作为票据和事后分析的附件非常有用，既可以记录具体的补救措施，也可以通过运行查询 API 并在笔记本中收集结果来记录“事情的状态”。通常，当以这种方式附加笔记本时，将其导出为更易于阅读的格式(如 HTML 或 PDF)并附加也是有用的。然而，越来越多的工具集成了直接笔记本查看，使得这一步变得多余。比如 GitHub 项目和 Gists 已经直接渲染笔记本了。

除了笔记本电脑，Jupyter 实验室还拥有一个基本但实用的基于浏览器的远程开发环境。第一部分是远程文件管理器。其中，这允许上传和下载文件。它的一个用途是能够从本地计算机上传笔记本，然后再下载回来。有更好的方法来管理笔记本，但在紧要关头，能够检索笔记本是非常有用的。类似地，还可以下载 Jupyter 的任何持久输出，比如经过处理的数据文件、图像或图表。

接下来，笔记本旁边是一个远程 IPython 控制台。虽然在笔记本旁边的使用有限，但仍然有一些情况下使用控制台更容易。通过使用 IPython 控制台，需要大量短命令的会话可以更加以键盘为中心，从而更加高效。

还有一个文件编辑器。虽然它与一个成熟的开发人员编辑器相差甚远，缺乏彻底的代码理解和完成，但在紧要关头它经常是有用的。它允许在远程 Jupyter 主机上直接编辑文件。一个用例是直接修复笔记本正在使用的库代码，然后重启内核。虽然将它集成到开发流程中需要一些小心，但是作为修复和继续的紧急措施，这是无价的。

最后，还有一个基于浏览器的远程终端。在终端、文件编辑器和文件管理器之间，运行的 Jupyter 服务器允许完全基于浏览器的远程访问和管理，甚至在考虑笔记本之前。记住这一点对安全性的影响很重要，但它也是一个强大的工具，我们将在后面探讨它的各种用途。现在，可以说，使用 Jupyter 笔记本给远程系统管理任务带来的能力是难以估量的。

## 3.6 摘要

反馈周期越快，我们就能越快地部署新的、经过测试的解决方案。交互式地使用 Python 可以获得最快的反馈:即时。

这通常有助于澄清一个库的文档，一个关于运行系统的假设，或者仅仅是你对 Python 的理解。

交互控制台也是一个强大的控制面板，当最终结果不能很好理解时，可以通过它启动计算:例如，调试软件系统的状态。