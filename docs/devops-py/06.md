# 六、文本操作

基于 UNIX 的系统的自动化通常涉及文本操作。许多程序是用文本配置文件配置的。文本是许多系统的输出格式和输入格式。虽然像`sed`、`grep`和`awk`这样的工具有它们的位置，但是 Python 是复杂文本操作的强大工具。

## 6.1 字节、字符串和 Unicode

当操作文本或类似文本的流时，很容易编写代码，当遇到外国名字或表情符号时会以有趣的方式失败。这些不再仅仅是理论上的担忧:你将拥有来自全世界的用户，他们坚持要求他们的用户名反映他们如何拼写他们的名字。有人会用表情符号写下`git`承诺。为了确保写出健壮的代码，公平地说，当他们处理一个凌晨 3 点的页面时，不会失败，看起来不那么*有趣，理解“文本”是一件微妙的事情是很重要的。*

你可以理解其中的区别，或者当有人试图用表情符号用户名登录时，你可以在凌晨 3 点醒来。

Python 3 有两种不同的类型，它们都代表了 UNIX“文本”文件中常见的内容:字节和字符串。字节对应于 RFC 通常所说的“八位字节流”这是一个适合 8 位的值序列，或者换句话说，是一个范围在 0 到 256(包括 0 但不包括 256)之间的数字序列。当所有这些值都小于 128 时，我们称这个序列为“ASCII”(美国信息交换标准代码)，并赋予这些数字 ASCII 赋予它们的含义。当所有这些值都在 32 和 128 之间(包括 32 但不包括 128)时，我们称该序列为“可打印的 ASCII”或“ASCII 文本”前 32 个字符有时被称为“控制字符”键盘上的“Ctrl”键就是一个参考——它最初的目的是能够输入这些字符。

ASCII 仅包含在“美国”使用的英语字母表为了用(几乎)任何语言表示文本，我们使用了 Unicode。Unicode 码位是介于 0 和`2∗∗32`(包括 0 和不包括`2∗∗32`)之间的(部分)数字。每个 Unicode 码位都被赋予一个含义。标准的后续版本保留了指定的含义，但增加了更多数字的含义。一个例子是增加了更多的表情符号。国际标准化组织 ISO 在其 10464 标准中批准了 Unicode 的版本。因此，Unicode 有时被称为 ISO-10464。

同样是 ASCII 的 Unicode 点具有相同的含义——如果 ASCII 赋予一个数字“大写 A”，那么 Unicode 也是如此。

正确地说，只有 Unicode 才是“文本”这就是 Python 字符串所代表的。用一个*编码*完成字节到字符串的转换，反之亦然。目前最流行的编码是 UTF 8。令人困惑的是，将字节*转换成*文本就是“解码”将文本转换成字节就是“编码”

为了处理文本数据，记住编码和解码之间的区别是至关重要的。记住它的一种方法是，由于 UTF-8 *是*编码，从字符串*移动到* UTF-8 编码的数据是“编码”，而从 UTF-8 编码的数据移动到字符串是“解码”

UTF-8 有一个有趣的特性:当给定一个恰好是 ASCII 的 Unicode 字符串时，它将产生带有码位值的字节。这意味着“在视觉上”，编码和解码的形式看起来是一样的。

```py
>>> "hello".encode("utf-8")
b'hello'
>>> "hello".encode("utf-16")
b'\xff\xfeh\x00e\x00l\x00l\x00o\x00'

```

我们展示了 UTF-16 的例子，以表明这不是编码的一个无关紧要的属性。UTF-8 的另一个特性是，如果字节是*而不是* ASCII，并且字节的 UTF-8 解码成功，那么它们不太可能是用不同的编码进行编码的。这是因为 UTF-8 被设计成*自同步*:从一个随机字节开始，有可能与被检查的有限字节数的字符串同步。自同步旨在允许从截断和损坏中恢复，但作为一个附带的好处，它允许*可靠地检测*无效字符，从而检测字符串是否是 UTF-8 开始。

这意味着“用 UTF-8 尝试解码”是安全的操作；它将对纯 ASCII 文本做正确的事情，当然，它将对 UTF-8 编码的文本起作用，而对既不是 ASCII 也不是 UTF-8 编码的文本——无论是不同编码的文本还是 JPEG 等二进制格式的文本——将彻底失败。

对于 Python 来说，失败意味着“抛出异常”

```py
>>> snowman = '\N{snowman}'
>>> snowman.encode('utf-16').decode('utf-8')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

```

对于随机数据，这也容易失败:

```py
>>> struct.pack('B'∗12,
                ∗(random.randrange(0, 256)
                for i in range(12))
 ).decode('utf-8')

```

误差是随机的，因为输入是随机的。一些错误示例可能是:

```py
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe2 in position 4: invalid continuation byte
UnicodeDecodeError: 'utf-8' codec can't decode byte 0x98 in position 2: invalid start byte

```

这是一个很好的练习，试着跑几次；几乎永远不会成功。

## 6.2 弦

Python 字符串对象很微妙。从一个角度来看，它似乎是一个字符序列:一个*字符*是一个长度为 1 的字符串。

```py
>>> a="hello"
>>> for i, x in enumerate(a):
...     print(i, x, len(x))

...

0 h 1
1 e 1
2 l 1
3 l 1
4 o 1

```

字符串“hello”有五个元素，每个元素都是长度为 1 的字符串。由于字符串是一个序列，通常的序列操作对它进行操作。

我们可以通过指定两个端点来创建切片:

```py
>>> a[2:4]
'll'

```

或者只是结尾:

```py
>>> a[:2]
'he'

```

或者仅仅是开始:

```py
>>> a[3:]
'lo'

```

我们也可以使用负指数从末尾开始计数:

```py
>>> a[:-3]
'he'

```

当然，我们可以通过指定一个负步长的扩展片段来反转字符串:

```py
>>> a[::-1]
'olleh'

```

然而，字符串也有相当多的方法是通用序列接口的*而不是*部分，在分析文本时非常有用。

`startswith`和`endswith`方法是有用的，因为文本分析通常在末端。

```py
>>> "hello world".endswith("world")
True

```

一个鲜为人知的特性是`endswith`允许一个字符串元组，并将检查它是否以这些字符串中的任何一个结尾:

```py
>>> "hello world".endswith(("universe", "world"))
True

```

一个有用的例子是测试一些常见的结尾:

```py
>>> filename.endswith((".tgz", ".tar.gz"))

```

我们可以很容易地在这里测试一个文件是否有一个 gzipped tarball 的通用后缀:或者是`tgz`或者是`tar.gz`后缀。

`strip`和`split`方法对于解析许多 UNIX 文件或工具中出现的特定格式非常有用。例如，文件`/etc/fstab`包含静态挂载。

```py
with open("/etc/fstab") as fpin:
    for line in fpin:
        line = line.rstrip('\n')
        line = line.split('#', 1)[0]
        if not line:
            continue
        device, path, fstype, options, freq, passno = line.split()
        print(f"Mounting {device} on {path}")

```

这将解析文件并打印摘要。循环中的第一行去掉了换行符。`rstrip`方法从字符串的右边(末尾)开始剥离。

请注意，`rstrip`和`strip`都接受要删除的字符序列。这意味着将一个*字符串*传递给`rstrip`意味着“该字符串中的任何字符”，而*不是*“移除该字符串的出现”这并不影响`rstrip`的单字符参数，但是这意味着更长的字符串几乎总是一种错误的用法。

然后我们删除评论，如果有的话。我们跳过空行。任何不为空的行，我们使用不带参数的`split`来分割任何空白序列。方便的是，这种约定对几种格式都是通用的，正确的处理内置于`split`的规范中。

最后，我们使用一个*格式*字符串来格式化输出，以便于使用。

这是字符串解析的一种典型用法，也是替代 shell 中长管道的那种代码。

最后，字符串上的`join`方法将它用作“粘合剂”,将字符串的 iterable 粘合在一起。

简单的例子`' '.join(["hello", "world"])`将返回`"hello world`、`"`，但这只是对`join`的皮毛。因为它接受一个 iterable，所以我们有能力向它传递任何支持迭代的东西。

```py
>>> names=dict(hello=1,world=2)
>>> ' '.join(names)
'hello world'

```

由于对字典对象的迭代产生了键的列表，将它传递给 join 意味着我们得到了一个包含键列表的字符串，它们连接在一起。

我们也可以传入一个生成器:

```py
>>> '-∗-'.join(str(x) for x in range(3))
'0-∗-1-∗-2'

```

这允许在运行中计算序列并连接它们，而不需要序列的中间存储。

关于`join`的常见问题是，为什么它是“粘合”字符串上的方法，而不是序列上的方法。原因正是这样:我们可以传入任何 iterable，粘合字符串将粘合其中的位。

注意`join`对单元素的可重复项没有任何作用:

```py
>>> '-∗-'.join(str(x) for x in range(0))
'0'

```

## 6.3 正则表达式

正则表达式是用于指定字符串属性的特殊 DSL，也称为“模式”它们在许多工具中很常见，尽管每个实现都有自己的特点。在 Python 中，正则表达式是由`re`模块实现的。它基本上允许两种交互模式——一种是在文本分析时自动解析正则表达式，另一种是预先解析正则表达式。

一般来说，后一种风格是首选。自动解析正则表达式只适用于交互式循环，在这种情况下，它们会很快被使用并被遗忘。出于这个原因，我们在这里不会真正涉及这种用法。

为了*编译*一个正则表达式，我们使用`re.compile`。该函数返回一个正则表达式对象，该对象将查找与表达式匹配的字符串。该对象可以用来做几件事:例如，查找一个匹配，查找所有匹配，甚至替换匹配。

正则表达式迷你语言有很多微妙之处。在这里，我们将只讨论说明如何有效使用正则表达式所需的基础知识。

大多数角色代表他们自己。例如，正则表达式`hello`与`hello`完全匹配。`.`代表任何字符。所以`hell`。将匹配`hello`和`hella`，但不匹配`hell`——因为后者没有任何对应于`..`方括号定界“字符类”的字符:例如，`wom[ae]n`匹配`women`和`woman`。字符类中也可以有范围——`[0-9]`匹配任何数字，`[a-z]`匹配任何小写字符，`[0-9a-fA-F]`匹配任何十六进制数字(十六进制数字和数字在很多地方都会出现，因为两个十六进制数字正好对应一个标准字节)。

我们还有“重复修饰语”,用来修饰它们前面的表达式。例如，`ba?b`同时匹配`bb`和`bab`—`?`代表“零或一”`∗`代表任意数字:所以`ba∗b`代表`bb`、`bab`、`baab`、`baaab`等等。`If`我们想要“至少一个”，`ba+b`将匹配`ba∗b`匹配的几乎所有内容，除了`bb`。最后，我们有确切的计数器:`ba{3}b`匹配`baaab`，而`ba{1,2}b`匹配`bab`和`baab`，除此之外别无其他。

为了让一个特殊字符(比如`.`或`∗`)匹配它自己，我们在它前面加了一个反斜杠。因为在 Python 字符串中，反斜杠有其他含义，所以 Python 支持“原始”字符串。虽然我们可以使用任何字符串来表示正则表达式，但原始字符串通常更容易。

例如，我们想要一个类似 DOS 的文件名正则表达式:`r"[^.]{1,8}\.[^.]{0,3}."`这将匹配，比如说，`readme.txt`但不匹配`archive.tar.gz`。请注意，要匹配文字。我们用反斜杠对它进行了转义。还要注意，我们使用了一个有趣的角色类:`[^.]`。这意味着“除了`.`之外的任何东西”:`^`意味着“排除”一个字符类内部。

正则表达式也支持*分组*。分组做两件事:它允许对表达式的一部分进行寻址，它允许将表达式的一部分作为单个对象来处理，以便对它应用重复操作之一。如果只需要后者，这是一个“非捕获”组，用`(?:....)`表示。

例如，`(?:[a-z]{2,5}-){1,4}[0-9]`将匹配`hello-3`或`hello-world-5`，但不匹配`a-hello-2`(因为第一部分不是两个字符长)或`hello-world-this-is-too-long-7`，因为它由内部模式的六个重复组成，我们指定最多四个。

这允许任意嵌套；例如，`(?:(?:[a-z]{2,5}-){1,4}[0-9];)+`允许前面模式的任何分号结束的、分隔的序列:例如，`az-2;hello-world-5;`将匹配，但`this-is-3;not-good-match-6`不匹配，因为它在末尾缺少了`;`。

这是一个很好的例子，说明正则表达式有多复杂。很容易在 Python 中使用这种密集的迷你语言来指定难以理解的字符串约束。

一旦我们有了一个正则表达式对象，上面主要有两个方法:`match`和`search`。`match`方法将在字符串的开头寻找匹配，而`search`将寻找第一个匹配，无论它可能从哪里开始。当他们找到一个匹配时，他们返回一个匹配对象。

```py
>>> reobj = re.compile('ab+a')
>>> m = reobj.search('hello abba world')
>>> m
<_sre.SRE_Match object; span=(6, 10), match="abba">
>>> m.group()
'abba'

```

经常使用的第一种方法是`.group()`，它返回字符串匹配的部分。如果正则表达式包含捕获组的*，这个方法可以得到部分匹配。一个捕获组通常标有`()`。*

```py
>>> reobj = re.compile('(a)(b+)(a)')
>>> m = reobj.search('hello abba world')
>>> m.group()
'abba'
>>> m.group(1)
'a'
>>> m.group(2)
'bb'
>>> m.group(3)
'a'

```

当组的数量很大时，或者当修改组时，管理组的索引可能是一个挑战。如果需要进行分组分析，也可以*将*分组。

```py
>>> reobj = re.compile('(?P<prefix>a)(?P<body>b+)(?P<suffix>a)')
>>> m = reobj.search('hello abba world')
>>> m.group('prefix')
'a'
>>> m.group('body')
'bb'
>>> m.group('suffix')
'a'

```

由于正则表达式可能会变得很密集，有一种方法可以使它们变得更容易阅读:详细模式。

```py
>>> reobj = re.compile(r"""
... (?P<prefix>a) # The beginning -- always an a
... (?P<body>b+)  # The middle -- any numbers of b, for emphasis
... (?P<suffix>a) # An a at the end to properly anchor
... """, re.VERBOSE)
>>> m = reobj.search("hello abba world")
>>> m.groups()
('a', 'bb', 'a')
>>> m.group('prefix'), m.group('body'), m.group('suffix')
('a', 'bb', 'a')

```

当编译带有标志`re.VERBOSE`的正则表达式时，空白被忽略，类似 Python 的注释:

`#`到行尾，也被忽略。为了匹配空格或`#`，它们需要被反斜杠转义。

这允许编写长正则表达式，同时通过明智的换行符、空格和注释使它们更容易理解。

正则表达式松散地基于有限自动机的数学理论。虽然它们*确实*超越了有限自动机所能匹配的约束，但它们并不完全通用。除此之外，它们不太适合*嵌套*模式；无论是匹配括号还是 HTML 元素，都不太适合正则表达式。

## 6.4 JSON

JSON 是一种分层的文件格式，它的优点是易于解析，并且相当容易手动读写。它起源于网络:这个名字代表“JavaScript 对象符号”的确，在网上还是比较流行的；关注 JSON 的一个原因是许多 web APIs 使用 JSON 作为传输格式。

然而，它在其他地方也是有用的。例如，在 JavaScript 项目中，`package.json`包括这个项目的依赖项。例如，对其进行解析通常有助于确定安全性或合规性审计的第三方依赖性。

理论上，JSON 是用 *Unicode* 定义的格式，而不是用*字节*定义的格式。序列化时，它接受数据结构并将其转换为 Unicode 字符串，反序列化时，它接受 Unicode 字符串并返回数据结构。然而，最近该标准被修改以指定一个首选编码:`utf-8`。有了这个增加，现在格式也被定义为一个字节流。

但是，请注意，在某些用例中，编码仍然与格式分离。特别是，当通过 HTTP 发送或接收 JSON 时，HTTP 编码是最终的真理。尽管如此，当没有明确指定编码时，应该采用 UTF-8。

JSON 是一种简单的序列化格式，仅支持几种类型:

*   用线串

*   民数记

*   布尔运算

*   一种`null`类型

*   JSON 值的数组

*   “对象”:将字符串映射到 JSON 值的字典

请注意，JSON 没有完全指定数值范围或精度。如果需要精确的整数，通常可以假设范围`-2∗∗53`到`2∗∗53`是可以精确表示的。

尽管 Python `json`库能够直接读写文件，但实际上我们几乎总是将任务分开；我们根据需要读取尽可能多的数据，并将字符串直接传递给 JSON。

在`json`模块中最重要的两个功能是`loads`和`dumps`。末尾的`s`代表“字符串”，这是这些函数接受和返回的内容。

```py
>>> thing = [{"hello": 1, "world": 2}, None, True]
>>> json.dumps(thing)
'[{"hello": 1, "world": 2}, null, true]'
>>> json.loads(_)
[{'hello': 1, 'world': 2}, None, True]

```

Python 中的`None`对象映射到 JSON `null`对象，Python 中的布尔映射到 JSON 中的布尔，数字和字符串映射到数字和字符串。请注意，Python JSON 解析库根据所使用的符号来决定一个数字应该映射到整数还是浮点数:

```py
>>> json.loads("1")
1
>>> json.loads("1.0")
1.0

```

重要的是要记住，不是所有的 JSON 加载库都做出相同的决定，在某些情况下，这可能会导致互操作性问题。

出于调试的原因，能够“漂亮地打印”JSON 通常是有用的。通过一些额外的参数，`dumps`函数可以做到这一点。支持漂亮印刷的通常论据如下:

```py
json.dumps(thing, sort_keys=True, indent=4)

```

如果我们想往返到一个等价的，但漂亮的版本，我们甚至可以这样做:

```py
json.dumps(json.loads(encoded_string), sort_keys=True, indent=4)

```

最后，在命令行中，模块: *json.tool* 将自动执行以下操作:

```py
$ python -m json.tool < somefile.json | less

```

这是浏览转储的 JSON 并寻找感兴趣的信息的一种简单方法。

注意，在 Python 3.7 及以上版本中，`sort_keys`要慎用；由于所有的字典都是按插入排序的，*而不是*使用`sort_keys`将保持字典中的原始顺序。

JSON 中一个经常遗漏的类型是日期-时间类型。通常这用字符串来表示，这是解析 JSON 的“模式”最常见的需求，以便知道哪些字符串要转换成`datetime`对象。

## 6.5 CSV

CSV 格式有几个优点。它是受约束的:它总是在二维数组中表示标量类型。正因如此，能进去的惊喜并不多。此外，它还是一种可以导入到 Microsoft Excel 或 Google Sheets 等电子表格应用中的格式。这在准备报告时很方便。

此类报告的示例包括为财务部门支付第三方服务的费用明细，或者为管理层提供的关于管理的事件和恢复时间的报告。在所有这些情况下，拥有一个易于生成和导入到电子表格应用中的格式可以轻松实现任务的自动化。

用`csv.writer`写 CSV 文件。一个典型的例子是序列化一个同质数组，一个相同类型的数组。

```py
@attr.s(frozen=True, auto_attribs=True)
class LoginAttempt:
    username: str
    time_stamp: int
    success: bool

```

该类表示某个用户在给定时间的登录尝试，并记录了该尝试的成功。对于安全审计，我们需要向审计员发送一个 Excel 文件，记录登录尝试。

```py
def write_attempts(attempts, fname):
    with open(fname, 'w') as fpout:
        writer = csv.writer(fpout)
        writer.writerow(['Username', 'Timestamp', 'Success'])
        for attempt in attempts:
            writer.writerow([
                attempt.username,
                attempt.time_stamp,
                str(attempt.success),
            ])

```

注意，按照惯例，第一行应该是“标题行”尽管 Python API 并不强制要求这样做，但强烈建议遵循这一约定。在这个例子中，我们首先写了一个带有字段名称的“标题行”。

然后我们循环尝试。请注意，CSV 只能表示字符串和数字，因此我们没有依赖于关于如何写出布尔值的简单标准，而是显式地这样做了。

这样，如果审计员要求该字段为“是/否”，我们可以改变我们的显式序列化步骤来匹配。

在读取 CSV 文件时，有两种主要方法。

使用`csv.reader`将返回一个迭代器，该迭代器以列表的形式逐行解析。然而，假设遵循了第一行是字段名称的约定，`csv.DictReader`将不会为第一行产生任何内容，并为随后的每一行产生一个*字典*，使用字段名称作为键。这使得在面对终端用户添加字段或改变它们的顺序时能够进行更健壮的解析。

```py
>>> reader = csv.DictReader(fileobj)
>>> list(reader)
[OrderedDict([('Username', 'alice'),
              ('Timestamp', '1514793600.0'),
              ('Success', 'False')]),
 OrderedDict([('Username', 'bob'),
              ('Timestamp', '1539154800.0'),
              ('Success', 'True')])]

```

读取我们在前面的例子中编写的相同的 CSV 将产生合理的结果。字典将字段名映射到值。需要注意的是，所有类型都被遗忘了，所有内容都以字符串的形式返回。不幸的是，CSV 不保存类型信息。

有时候，用`.split`来“即兴”解析 CSV 文件是很诱人的。然而，CSV 有相当多的不明显的极限情况。

例如，

```py
1,"Miami, FL","he""llo"

```

被正确地解析为

```py
('1', 'Miami, FL', 'he"llo')

```

出于同样的原因，避免使用除了`csv.writer` `.`之外的任何东西来编写 CSV 文件是一个好主意

## 6.6 总结

许多 DevOps 任务所需的大部分内容以文本形式出现:日志、数据结构的 JSON 转储或付费许可证的 CSV 文件。理解什么是“文本”,以及如何在 Python 中操作它，可以实现作为 DevOps 基石的许多自动化，无论是通过构建自动化、监控结果分析，还是仅仅准备摘要以方便他人使用。