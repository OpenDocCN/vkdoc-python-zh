# 九、Paramiko

Paramiko 是一个实现 SSH 协议的库，通常用于远程管理 UNIX 系统。SSH 最初是作为“telnet”命令的安全替代物而发明的，但很快成为事实上的远程管理工具。即使是使用定制代理来管理服务器群的系统，比如`Salt`，通常也会使用 SSH 引导来安装定制代理。当一个系统被*描述为*的“无代理”，例如 Ansible，通常意味着它使用 SSH 作为底层管理协议。

Paramiko 包装了协议，允许高级和低级抽象。在这一章中，我们将主要关注高层次的抽象。

在深入研究细节之前，值得注意的是 Paramiko 与 Jupyter 的协同作用。使用 Jupyter 笔记本，并在其中运行 Paramiko，可以实现强大的自动记录远程控制控制台。将多个浏览器连接到同一台笔记本电脑的能力意味着它具有为远程服务器共享故障排除会话的固有能力，而无需繁琐的屏幕共享。

## 9.1 SSH 安全性

“SSH”中的“S”代表“安全”使用 SSH 的原因是因为我们相信它允许我们安全地控制和配置远程主机。然而，安全是一个微妙的话题。即使底层的加密原语和协议使用它们的方式是安全的，我们也必须正确使用它们，以防止误用造成为成功攻击打开大门的问题。

为了安全地使用 SSH，理解 SSH 如何考虑安全性是很重要的。不幸的是，它是在“安全性的可承受性”没有被认为是高度优先的时候建造的。SSH 很容易使用，这就否定了它带来的所有安全性好处。

SSH 协议建立了*相互信任*——客户端确信服务器是可信的，服务器也确信客户端是可信的。有几种方法可以建立这种信任，但是在这个解释中，我们将介绍公钥方法。这是最常见的一种。

服务器的公钥由一个*指纹*识别。该指纹以两种方式之一确认服务器的身份。一种方式是通过先前建立的安全通道进行通信，并保存在文件中。

例如，当 AWS EC2 服务器启动时，它将指纹打印到它的虚拟控制台。控制台的内容可以使用 AWS API 调用(使用 web 的 TLS 模型保护)来检索，并解析以检索指纹。

可悲的是，另一种更受欢迎的方式是豆腐模式——“第一次使用时的信任”。这意味着在初始连接中，指纹被认为是可信的，并存储在本地的安全位置。在任何后续尝试中，将对照存储的指纹检查指纹，不同的指纹将被标记为错误。

指纹是服务器公钥的散列。如果指纹相同，则意味着公钥相同。服务器可以证明它知道对应于给定公钥的私钥。换句话说，服务器可以说“这是我的指纹”，并证明它确实是具有该指纹的服务器。因此，如果指纹得到确认，我们就与服务器建立了加密信任。

另一方面，用户可以向服务器表明他们信任哪些公钥。同样，这通常是通过一些带外机制实现的:供系统管理员放入公钥的 web API、共享文件系统或从网络读取信息的引导脚本。不管是如何做到的，用户的目录可以包含一个文件，意思是“请授权连接，该连接可以证明它们具有与来自我的*这个*公钥相对应的私钥。”

当 SSH 连接建立后，客户机将如上所述验证服务器的身份，然后提供证据证明它拥有一个与服务器上的某个公钥相对应的私钥。如果这两个步骤都成功，则可以双向验证连接，并且可以用于运行命令和修改文件。

## 9.2 客户端密钥

客户端私钥和公钥保存在相邻的文件中。通常用户已经有一个现有的密钥，但如果没有，这很容易补救。

从`paramiko`开始，生成密钥本身很容易。我们选择一个`ECDSA`键。`EC`代表“椭圆曲线”对于相同的密钥长度，椭圆曲线非对称加密比基于素数的加密具有更好的抗攻击性。在 EC 加密的“部分解决方案”方面也有很少的进展，因此加密社区的共识是它们可能对“非公开”参与者更安全。

```py
>>> from paramiko import ecdsakey
>>> k = ecdsakey.ECDSAKey.generate()

```

与非对称加密技术一样，从私钥部分计算公钥部分既快速又简单。

```py
>>> public_key = k.get_base64()

```

因为这是公开的，所以我们不必太担心把它写到文件中。

```py
>>> with open("key.pub", "w") as fp:
...    fp.write(public_key)

```

然而，当我们写出密钥的私有部分时，我们希望确保文件权限是安全的。我们这样做的方法是，在打开文件之后，但在写入任何敏感数据之前，我们改变模式。

请注意，这并不完全安全；如果写入错误的目录，文件可能会有错误的用户，并且由于一些文件系统会单独同步数据和元数据，因此在错误的时间崩溃可能会导致数据在文件中，但附加了错误的文件模式。这仅仅是我们安全地写一个文件需要做的最少的事情。

```py
>>> import os

>>> with open("key.priv", "w") as fp:
...   os.chmod(0o600, "key.priv")
...   k.write_private_key(fp)

```

我们选择模式`0o600`，是八进制`600`。如果我们写与这个八进制代码相对应的位，它们是`110000000,`，翻译成`rw-------:`所有者的读写权限，非所有者组成员没有权限，其他任何人都没有权限。

现在通过一些带外机制，我们需要将公钥推送到相关的服务器。

例如，根据云服务的不同，代码如下:

```py
set_user_data(machine_id,
f"""
ssh_authorized_keys:
   - ssh-ecdsa {public_key}
""")

```

其中`set_user_data`是使用云 API 实现的，将在任何使用 cloudinit 的服务器上工作。

有时做的另一件事是使用 Docker 容器作为堡垒。这意味着我们希望用户通过 SSH 进入容器，并从容器进入他们需要运行命令的特定机器。

在这种情况下，构建时的一条简单的`COPY`指令(或者运行时的一条`docker cp`,视情况而定)就可以实现目标。请注意，向 Docker 注册中心发布包含公钥的图像是完全可以的——事实上，这是一个安全操作的要求是公钥定义的一部分。

## 9.3 主机身份

如前所述，SSH 中针对中间人攻击的最常见的第一道防线是所谓的豆腐原则——“第一次使用时的信任”为此，在连接到主机后，其指纹必须保存在缓存中。

该缓存的位置过去很简单——用户主目录中的一个文件。然而，更现代的不可变的、一次性的环境、多用户机器和其他复杂因素使这变得更加复杂。

很难提出比“与尽可能多的可信来源分享”更普遍的建议然而，为了实现该准则，Paramiko 确实提供了一些设施:

*   客户端可以设置一个`MissingHostKeyPolicy`，它是支持接口的任何实例。这意味着我们可以用逻辑来记录密钥，或者从外部数据库中查询它。

*   UNIX 系统上最常见格式的抽象，`known_hosts`文件。这允许 Paramiko 与常规 SSH 客户端共享使用密钥的经验——通过读取密钥和记录新条目。

## 9.4 连接

虽然有较低级别的连接方式，但推荐的高级接口是`SSHClient`。

因为需要关闭`SSHClient`实例，所以使用`contextlib.closing`作为上下文管理器是一个好主意(如果可能的话):

```py
with contextlib.context(SSHClient()) as client:
    client.connect(some_host)
    ## Do things with client

```

在接近顶层的地方这样做允许我们使用`client`作为函数的参数，同时保证它将在最后关闭。

有时，在连接之前，我们希望在客户机上配置各种策略。在返回准备好连接的客户端的函数中这样做有时很有用。

以下是与验证真实性的方式相关的一些有用的连接准备方法:

*   `load_system_host_keys`将从由其他系统管理的源加载密钥。这意味着它们将用于验证主机，但如果我们选择保存密钥，它们将不会被保存。

*   `load_host_keys`将从我们管理的来源加载密钥。这意味着，如果我们选择保存密钥，这些密钥也会被一起保存。例如，我们可能有一个包含连续文件的目录，`keys.1`，`keys.2`，。。。并从最新版本加载。我们可以在保存时保存到较新的文件，从而有一个安全的方法来从问题中恢复(只需加载以前的版本)。

*   `set_missing_host_policy(policy)`需要一个方法为`missing_host_key`的对象。这个方法会用`client, hostname, key`调用，它的行为会决定做什么；异常将停止连接，而成功的返回将允许连接继续进行。例如，这可以将主机的密钥放在一个“临时”文件中，并引发异常。用户可以查看临时文件，遵循验证过程，并将密钥添加到下一次迭代加载的文件中。

`connect`方法有相当多的参数。除了`hostname`都是可选的。比较重要的有以下几条:

*   `hostname`–要连接的服务器。

*   如果我们在 22 以外的特殊端口上运行，则需要。这有时是作为安全协议的一部分来完成的；尝试连接到端口 22 会自动拒绝来自该 IP 的所有进一步连接，而真正的服务器运行在`5022`或只能通过 API 发现的端口上。

*   `username`–虽然默认是本地用户，但这种情况越来越少。云虚拟机映像通常有一个默认的“系统”用户。

*   `pkey`–用于认证的私钥。如果我们想通过某种编程方式获得私钥(例如，从秘密管理器中检索)，这是很有用的。

*   `allow_agent`–默认情况下这是`True`，原因很简单。这通常是一个好的选择，因为这意味着私钥本身将永远不会被我们的进程加载，并且通过扩展，不会被我们的进程泄露:没有意外的日志记录、调试控制台或内存转储是易受攻击的。

*   `look_for_keys`–设置为`False`，不给出其他按键选项，强制使用代理。

## 9.5 运行命令

SSH 中的“SH”代表 shell。最初的 SSH 是作为 telnet 的替代品发明的，它的主要工作仍然是在远程机器上运行命令。请注意，“远程”是一个比喻，并不总是字面意思。SSH 有时用于控制虚拟机，有时甚至是容器，它们可能就在附近运行。

Paramiko 客户端连接后，它可以在远程主机上运行命令。这是使用客户端方法`exec_command`完成的。注意，这个方法把要执行的命令*作为字符串*，而不是列表。这意味着在命令中插入用户值时必须格外小心，以确保用户没有完全的执行权限。

返回值是命令的标准输入、输出和错误。这意味着小心地与命令通信以避免死锁的责任牢牢地掌握在最终用户手中。

客户端还有一个方法`invoke_shell`，它将创建一个远程 shell 并允许对它进行编程访问。它返回一个`Channel`对象，直接连接到 shell。在通道上使用`send`方法会将数据发送到 shell——就像一个人在终端上打字一样。类似地，`recv`方法允许检索输出。

请注意，这可能很难做到，尤其是在时机方面。一般来说，使用`exec_command`要安全得多。很少需要打开显式 shell，除非我们需要在终端中正确运行命令。例如，远程运行`visudo`将需要一个真正的类似 shell 的访问。

## 9.6 模拟外壳

我们已经提到客户端有一个`invoke_shell`，它将创建一个远程 shell 并允许对它进行编程访问。

虽然我们可以在返回的`Channel`上使用`send`和`recv`方法，但有时将它作为文件使用更容易。

```py
>>> channel = client.invoke_shell()
>>> input = channel.makefile("wb")
>>> output = channel.makefile("rb")

```

现在可以用`input.write`写命令的输入，用`output.write`读。请注意，这仍然很微妙:计时和缓冲效应仍然会导致不确定性问题。

注意，不需要重新连接，总是可以`channel.close`并创建一个新的 shell。因此，确保 shell 的使用是幂等的是一个好主意。在这种情况下，简单的超时可以帮助从流被“阻塞”、关闭和重试的情况中恢复。

## 9.7 远程文件

为了启动文件管理，我们调用客户端的`open_sftp`方法。这将返回一个`SFTPClient`对象。我们将在这个对象上使用方法来进行所有的远程文件操作。

在内部，这将在同一个 TCP 连接上启动一个新的 SSH 通道。这意味着，即使来回传输文件，该连接仍可用于向远程主机发送命令。SSH 没有“当前目录”的概念虽然`SFTPClient`模拟了它，但是最好避免依赖它，而是对所有文件操作使用完全限定的路径。这将使代码更容易重构，并且不会对操作顺序有微妙的依赖。

### 元数据管理

有时我们不想改变数据，而只是改变文件系统的属性。`SFTPClient`对象允许我们进行我们期望的正常操作。

`chmod`方法对应于`os.chmod`——它采用相同的参数。由于`chmod`的第二个参数是一个被解释为许可位域的整数，所以最好用八进制表示法来表达。因此，将文件设置为“常规”权限(所有者读/写，全局读取)的最佳方式是:

```py
client.chmod("/etc/some_config", 0o644)

```

注意，从 C 中借用的`0644`符号在 Python 3 中不工作(在 Python 2 中已被否决)。`0o644`符号更加明确和 Pythonic 化。

可悲的是，没有什么能保护我们不去理会这样的废话:

```py
client.chmod("/etc/some_config", 644)

```

(这将对应于目录列表中的`-w----r--`,这并不安全——但是非常混乱！)

更多的元数据操作方法有:

*   `chown`

*   `listdir_iter`–用于检索文件名和元数据

*   `stat, lstat`–用于检索文件元数据

*   `posix_rename`–用于自动更改文件的名称(不要使用`rename`–它有令人困惑的不同语义，在这一点上是为了向后兼容)

*   `mkdir`、`rmdir`–创建和删除目录

*   `utime`–设置文件的访问和修改次数

### 上传

用 Paramiko 上传文件到远程主机主要有两种方式。一种是简单用`put`。这绝对是最简单的方法——给它一个本地路径和一个远程路径，它就会复制文件。该函数还接受其他参数——主要是一个回调函数，用于调用中间进度。然而，在实践中，如果需要这种复杂性，最好以不同的方式上传。

`SFTPClient`上的`open`方法返回一个打开的类似文件的对象。编写一个远程逐块或逐行复制的循环相当简单。在这种情况下，进度逻辑可以嵌入到循环本身中，而不是必须提供回调函数，并仔细维护调用之间的状态。

### 9.7.3 下载

与上传非常相似，有两种方法可以从远程主机检索文件。一种是通过`get`方法，它获取远程和本地文件的名称，并管理复制。

另一种方法是再次使用`open`方法，这次是以读模式而不是写模式，逐块或逐行复制。同样，如果需要进度指示器，或者需要来自用户的反馈，这是更好的方法。

## 9.8 摘要

大多数基于 UNIX 的服务器可以使用 SSH 协议进行远程管理。Paramiko 是 Python 中自动化管理任务的一种强大方法，同时对任何服务器做了最少的假设:它运行一个 SSH 服务器，并且我们有登录的权限。