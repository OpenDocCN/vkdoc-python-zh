# 七、为 Db2 编写优秀的 SQL

编写好的 SQL 实际上是关于数据库性能的。尽管数据库调优有助于提高性能，但糟糕的 SQL 会以调优数据库无法解决的方式影响性能。当数据库管理员完成他们的工作后，就该开始培训用户了。所有关系数据库都有自己的怪癖，对于用户来说，意识到这些怪癖并了解如何绕过它们或创建利用数据库设计和特性的 SQL 是至关重要的。

Db2 被设计用来保存和处理大量数据。因此，许多设计目标和特性与其他关系数据库有很大不同。SQL 优化器是业内最复杂的优化器之一。数据库数据可以分布在各种设备和一系列计算实体上。所有这些能力的获得都是有代价的，本章关注 SQL 的设计和使用。

本章将介绍一些简单的方法来构建 SQL，以利用 Db2 设计的优势。它将涵盖多个领域，以便您能够很好地理解 Db2 是如何工作的，以及如何让您的 SQL 性能更好。

## 关系理论

关系数据库是围绕集合的数学理论设计的。集合论是一个非常古老的、被理解的关于实体或数据之间关系的理论。所有关系数据库的核心都是集合论。

由于这种设计，数据库中的数据存储实际上与传统的文件系统没有任何相似之处。这使得程序员和用户都很难理解为什么不应该用传统的方式做事。教给新用户的第一件事是，以传统方式做事总是会对数据库性能造成不利影响。在某些情况下，性能会比顺序访问相同数据的文件差。

关系数据库内置了巨大的能力。当使用 Db2 时，您应该总是尝试利用这种能力，主要是因为这几乎总是比尝试设计自己的解决方案要好。

新用户犯的一个错误是将数据库表视为一个文件。它们不是文件，甚至一个表行中的数据也不存储在一起。原因可以追溯到设计的集合论。动态结构化数据总是比分解结构化数据并将其重组为结果集更容易。

新用户犯的下一个错误是认为结果集的构造一次只发生一点点。这是一个大错误。当第一个结果行呈现给用户时，系统已经完成了完整的结果集。因此，一次处理一行结果集会延迟结果集的销毁，并会耗尽宝贵的系统暂存空间。

对于新用户和程序员来说，这是两个非常大的问题，但是程序员特别容易犯的另一个错误是在获取数据后处理数据以产生新的结果。新程序员有时会认为数据库系统在动态修改结果方面效率低下——比如向结果列添加固定的数值。事实并非如此。数据库系统在这种计算上比任何程序都要快得多。

新用户有时也害怕创建复杂的 SQL，认为系统会发现很难解释有效的结果。Db2 的 SQL optimizer 非常有效地分解输入 SQL，并高效地解释和执行它。

用户犯的最后一个错误是编写 SQL 来请求您已经知道的数据。例如，如果您需要 Dept. 4 的数据，就不要在结果集中包含部门号。这只是浪费时间和资源。

最后要介绍的是 Db2 中使用的数据类型，并将它们与硬件系统的本地数据类型进行对比。例如，很少有较小的系统本身支持十进制数据。有时有一些库可以处理这些数据，但即使这样，也需要一些编程来适应十进制数据。

## 减少数据传递

减少 SQL 查询处理的最简单方法之一是消除对同一数据的多次传递。例如，如果您正在寻找工资超出范围的雇员，您可以创建两个查询来返回数据:

```py
SELECT firstnme, midinit, empno
   FROM emp
   WHERE salary > 75000;

SELECT firstnme, midinit, empno
   FROM emp
   WHERE salary < 10000;

```

这两个查询将返回工资高于或低于该工资范围的雇员。如果员工数量非常大，每个查询都需要一些时间来处理。这里的问题是我们真正想要回答的问题是什么“员工超出范围”这个基本问题可以用一个简单的查询来回答:

```py
SELECT firstnme, midinit, empno
   FROM emp
   WHERE salary > 75000 OR salary < 10000;

```

该查询将对数据进行一次遍历，以列出高于或低于该范围的所有雇员。

当需要两次查询来获得数据时，总是从一个问题后退是非常重要的。尝试找出你问的基本问题，因为这通常会导致一个真正回答你的问题的查询。

下面是另一个例子，说明多次传递如何渗透到 SQL 代码中:

```py
SELECT creator, name, 'Table '
   FROM sysibm.systables
   WHERE type = 'T'
UNION
SELECT creator, name, 'View  '
   FROM sysibm.systables
   WHERE type = 'V'
UNION
SELECT creator, name, 'Alias '
   FROM sysibm.systables
   WHERE type = 'A'
UNION
SELECT creator, name, 'Global'
   FROM sysibm.systables
   WHERE type = 'G'
ORDER BY creator, name;

```

这个简单的语句导致四次通过`sysibm.systables`表。结果输出显示了数据库目录中所有类似表格的对象。但是，该语句可以简化，只需要对`sysibm.systables`表进行一次遍历。

当联接两个或多个表时，WHERE 子句引用所引用的每个表中的索引列将非常有用。所有这些都是为了防止在每个表中查找正确行的完整表扫描:

```py
SELECT creator, name,
   CASE type
      WHEN 'T' THEN 'Table '
      WHEN 'V' THEN 'View  '
      WHEN 'A' THEN "Alias '
      WHEN 'G' THEN 'Global'
   END
   FROM sysibm.systables
   ORDER BY creator, name;

```

这个新查询提供了与前一个相同的结果，但是只需要一次通过`sysibm.systables`表。它也更容易阅读和理解。

下面显示了如何只通过一次表就可以进行批量更新:

```py
UPDATE emp
SET salary = CASE workdept
      WHEN 'A01' THEN salary * .04
      WHEN 'C01' THEN salary * .02
      WHEN 'D11' THEN salary * .10
      WHEN 'D21' THEN salary * .50
      ELSE salary * .01
   WHERE edlevel > 15;

```

## 使用索引提高性能

当从数据库中查询数据时，尽可能利用索引非常重要。性能的提高可能非常显著。您不一定要获取有索引的列，而是尽可能在 SQL WHERE 子句中利用它们。例如，如果`empno`列上有一个索引，您应该尝试在查询中使用该索引:

```py
SELECT firstnme, midinit, lastnme, dept
   FROM emp
   WHERE empno > 10000

```

前面的语句现在将利用索引来定位雇员行，而不需要全表扫描。列`empno`有一个索引；因此，Db2 可以使用它来定位要返回的行。请注意，没有必要检索索引列来利用它的索引。WHERE 子句中的引用足以防止全表扫描。

另外，您应该知道 Db2 可以动态地创建索引来帮助查询一个或多个表。例如，下面的 WHERE 子句将导致在`salary`、`bonus`和`comm`列上创建动态索引，以帮助减少数据的访问时间:

```py
SELECT empno, firstnme, lastnme
FROM emp
WHERE salary + bonus + comm > 100000.00;

```

创建的索引只是临时的，在查询完成后将被删除。

## 排序和分组

对于新的 SQL 用户来说，排序有时是一个令人困惑的话题，因为有一些基本的规则来管理它。此外，排序可以由 ORDER BY 子句或 SELECT 子句上的 DISTINCT 关键字调用。

ORDER BY 子句的一个特点是，不必在输出中检索该子句中指定的列(出现在 SELECT 关键字之后)。许多新用户总是对输出数据的排序感到惊讶。这里显示了一个示例:

```py
SELECT empno, lastnme, firstnme
FROM emp
ORDER BY workdept;

```

如您所见，`workdept`没有出现在输出中，但是数据将按该值排序。

您还应该限制要排序的列数。包含的列越多，排序所需的时间就越长。

DISTINCT 关键字总是导致排序，即使没有重复的行。使用 DISTINCT 时应该非常小心，因为开销可能会很高。但是，这并不是建议永远不要使用它，因为这样做可能有非常正当的理由。

当您想要返回聚合数据时，使用 SQL 进行分组非常有用。考虑以下查询:

```py
SELECT workdept, SUM(salary)
   FROM emp
   GROUP BY workdept;

```

这导致输出包含每个`workdept`的单行以及`workdept`中所有雇员的工资总和。由于没有使用 ORDER BY 子句，`workdept`的顺序将是随机的。此外，HAVING 子句可以消除对您无用的部门:

```py
SELECT workdept, SUM(salary)
   FROM emp
   GROUP BY workdept
   HAVING AVG(salary) < 15000;

```

## 包含 SQL 的程序

包含 SQL 的程序有时被称为“黑盒代码”，因为运行程序的用户看不到 SQL。这些程序是由程序员创建的，他们根据用户创建的一组需求工作。当程序员在为程序编写 SQL 时走捷径时，问题就出现了。让我们来看一个例子，它会使 SQL 效率低下，从而导致程序效率低下。

如果程序需要来自`customer`表的三种不同类型的数据，最好的方法是针对`customer`表编写三个不同的查询:

```py
SELECT firstnme, lastnme, address, city, state, zipcode
    FROM customer
    WHERE areacode = :HV-AC;

SELECT custid, firstnme, lastnme, phoneno
   FROM customer
   WHERE areacode = :HV-AC;

SELECT custid, firstnme, lastnme, custtype
   FROM customer
   WHERE areacode = :HV-AC;

```

前面所有的查询都非常高效，只需要很少的数据库资源。但是，以减少编程工作量的名义，程序员可能会决定对它们进行如下编码，以减少程序中 SQL 语句的数量:

```py
SELECT custid, firstnme, lastnme, address, city, state, zipcode, phonno, custtype
    FROM customer
    WHERE areacode = :HV-AC;

```

这远不如前三个查询有效。这也是不好的形式，因为它总是返回用户不感兴趣的列。底线是这是一个可怕的想法。虽然它看起来节省了程序员的时间，但每次运行查询时，它都会浪费用户的时间和数据库资源。

## 尽可能使用 Db2 工具

程序员和用户都应该研究使用 Db2 工具代替定制程序的可能性。在大多数情况下，Db2 工具比程序员创建的程序要高效得多。Db2 中的绝大多数工具已经存在了几十年，并且已经消除了 99%的错误。此外，这些公用事业的效率已经磨砺了多年，远远超过任何其他本地创建的程序。

`load`和`import`工具可用于添加或替换现有表格中的数据。这些工具非常高效，尤其是`load`工具。它们还可以处理非常大的输入数据集。这些工具支持许多选项，可以修改数据加载到表中的方式，包括跳过一些输入数据。

`unload`工具可以非常快速地从一个表中大量提取数据。它使用 SQL 语句来确定要卸载的数据，因此用户可以很容易地修改它来满足他们的需求。

MERGE SQL 语句虽然不是 Db2 工具，但它是从两个表中获取数据并将其合并到一个表中的另一种方式。这是一个非常强大的 SQL 语句，有许多选项用于匹配要合并的数据。

TRUNCATE SQL 语句是另一个不是 Db2 工具的工具。这一条语句可以删除表中的所有数据，并选择性地回收表所占用的存储空间。

## Db2 函数

Db2 系统提供了大量的内置函数(BIFs ),可以在 SQL 语句中使用这些函数，从而改进对您正在寻找的确切数据的检索。这些函数和 SQL 语句本身一样，都是 SQL 和 Db2 优化器的一部分。在 SQL 语句中使用它们通常不会导致性能问题。

从广义的角度来看，Db2 提供了两种类型的功能。有由数据库提供的内置函数，也有由用户和程序员提供的用户开发函数。内置函数非常高效，任何为 Db2 开发 SQL 语句的人都可以使用。用户定义的函数必须由程序员开发，以便可用于 SQL 语句。

BIF 有多种类型，下面列出了其中几种:

*   聚合函数:这些函数用于计算包含在一行或多行中的一列的汇总信息，并以某种形式进行汇总。

*   标量函数:这些函数在单行中返回列数据的子集。

*   表函数:这些函数从 WHERE 子句中返回一组列。

*   行函数:这些在 LUW 版 Db2 中还不可用。

下面列出了当前的 Db2 BIFs:

ABS:从一组行中返回一列的绝对值。

AVG:计算一组列值的平均值。

CEILING:返回大于或等于参数的最小整数值。

CHAR:返回参数的固定长度字符串。

COALESCE:返回第一个非空表达式的值。

CONCAT:返回两个兼容字符串参数的串联。

CORRELATION:返回任何内置数值数据类型的值的表达式。

COUNT:计算列结果中的行数。

协方差:返回一组数字对的总体(协方差)。

DATE:返回从表达式中导出的 Db2 日期。

IDENTITY_VAL_LOCAL:返回 IDENTITY 元素的最近赋值。

INT:返回数字的整数或整数的字符串表示形式。

LENGTH:返回值的长度。

LOCATE:返回一个参数在另一个参数中第一次出现的位置。

LOWER:以小写形式返回参数字符串。

LPAD:返回一个左边带空格的填充字符串参数(或另一个字符串)。

LTRIM:返回一个从字符串左边移除了字节的字符串。

MAX:返回一组行中某列的最大值。

MIN:返回一组行中某列的最小值。

POSITION:返回一个参数在另一个参数中第一次出现的位置。

RAND:返回一个介于 0 和 1 之间的随机浮点数。

REPLACE:返回一个字符串，其中包含该字符串与另一个字符串的所有匹配项。

ROUND:返回舍入到小数点右边或左边指定位数的数字。

RPAD:返回右边带空格的填充字符串参数(或另一个字符串)。

RTRIM:返回一个从字符串右侧移除了字节的字符串。

SQRT:返回参数的平方根。

STDDEV:返回一列中一组行的标准偏差。

SUBSTR:返回字符串参数的子字符串。

SUM:返回一组行中所有列的总和。

UPPER:以大写形式返回参数字符串。

UNNEST:返回一个结果表，其中包含数组中每个元素的一行。

VARIANCE:返回一组行中所有列的方差。

## 编写 SQL 的多种方法

使用 SQL，就像任何其他语言一样，有多种方法可以从查询中获得想要的结果。检查以下语句:

```py
SELECT empno, lastname
    FROM emp
    WHERE workdept LIKE 'A%';

```

虽然这可能会得到您想要的结果，但它可能会返回比您预期的多得多的一组行。前面的陈述假设您知道只有三个部门以字母“a”开头，但是将来，以该字母开头的部门可能会多得多。一个更好的替代方法是编写您所知道的代码，以防止将来出现问题并提高效率:

```py
SELECT empno, lastname
    FROM emp
    WHERE workdept IN('A00', 'A01', 'A02');

```

这至少会给你正确的目标结果，但也会提高性能。

## 摘要

本章介绍了几个单独的主题，都是为了帮助您为 Db2 数据库编写好的 SQL。好的 SQL 被定义为高效、合理、易读。编写好的 SQL 的结果是容易理解和维护。