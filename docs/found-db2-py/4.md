# 四、数据库物理设计

关系数据库的物理设计是一个两阶段的项目。第一阶段涉及表及其关系的设计。第二阶段将表设计布置到系统提供的物理驱动器上。这两个阶段对于数据库信息的适当优化都是必要的。但是这两个阶段之间存在不可避免的冲突，需要在性能测试期间解决。

本章将介绍这些阶段中的每一个，并强调可能的冲突会降低数据库性能的地方。不要被本章的概念所迷惑。这些主题只有在深入理解可能出错的地方时才会涉及。程序员可能认为这一章并不适用于他们，但是他们的假设是错误的。程序员需要理解数据库设计者所做的选择，以便他们能够正确地编写 SQL 语句，从而充分利用设计。

关系数据库物理设计的第 1 阶段包括收集数据和一个称为数据规范化的过程。规范化是以某种方式组织表数据以减少对同一表或其他表中其他数据的依赖性的过程。规范化过程有三个步骤。每一步都将表格转换成第一范式、第二范式或第三范式。所有这些步骤都涉及到创建表，只包含对用户有用的数据。达到的深度决定了标准化的程度。

物理设计的第 2 阶段将第 1 阶段创建的表及其对应的表空间放在一个物理驱动器上。该驱动器可能是新的 SSD 内存设备之一，也可能是旋转磁盘或 RAID 系统。较少使用的数据甚至可以放在更慢的介质或远程系统上。用于存储的介质类型严格取决于所存储数据的性能要求。

数据库设计者的基本问题是平衡用户的需求与数据库可用的系统和介质。这实际上意味着两个阶段应该一起完成。单独执行每个阶段会有一个阶段影响另一个阶段的风险，可能会导致前一个阶段部分重做。

## 阶段 1:数据收集和标准化

这个阶段收集构成数据库的数据，然后对其进行规范化。这个阶段也称为数据的逻辑模型。

这一阶段需要明确的一点是，数据用户需要大量参与为数据库收集和组织数据。如果没有别的，这将帮助您发现将对数据进行的查询类型。这些查询将帮助您以这样一种方式组织数据，既提高查询性能，又创建对用户既有逻辑又有帮助的设计。

### 数据采集

这项任务可能涉及许多小组，尤其是当数据来自现有来源时。以下是可能需要参与收集数据的潜在群体列表:

*   要设计的数据库的最终用户

    这群人将使用您的数据库中包含的数据。他们还可能从新数据库的任何现有源数据中获得见解。他们可能设计查询，也可能不设计查询，但是他们期望从数据中获得信息。

*   数据库源数据的所有者

    该组是将用于新数据库的任何源数据的所有者。如果需要对此数据进行任何更改/添加，您将需要通知该组，并将这些更改的所有权交给该组。

*   维护数据库物理硬件的组

    这个组将是数据库所在的物理硬件的维护者。随着新数据库大小的公开，该小组将负责维护该硬件。此外，如果需要购买硬件，该团队很可能会参与硬件的购买和安装。

*   负责数据备份的小组

    该组维护新数据库的所有备份和恢复映像。可能需要为该任务购买和安装硬件，因此该组需要参与该任务。

*   数据库的 IT 管理

    管理层需要参与批准任何新的硬件采购和/或新的数据库维护人员。

如您所见，有许多人参与设计数据库。在您的组织中，甚至可能有需要在流程的不同点引入的其他组。

数据收集涉及一系列潜在来源，具体取决于数据类型。这些来源可能涉及其他数据库、磁带上的数据、在线来源、自动输入、手动数据输入，甚至来自其他公司或政府机构的来源。所有数据源传递数据的方式会影响数据的及时性，也会影响对数据库的查询。

一旦你对进来的数据有了概念，就该组织它了。您和最终用户将需要定义在数据中容易识别的潜在实体。此外，您可能能够重新组织数据以形成新的实体，从而更好地反映数据的组织。当然，在创建表组织时，您可能需要额外的表和/或索引，用户不会直接使用它们来维护数据/表关系。

此时创建的任何表组织都应被视为临时的。这应该让你的用户非常清楚。设计稳定还有很长的路要走，大家要意识到这一点。

### 数据标准化

规范化包括从表中删除冗余，并从表中删除实际上不是表实体属性的实体。这非常类似于用设计 OOP 类定义的相同方式来组织一个表。不是主表实体属性的东西应该从表中删除。通常需要创建一个或多个新表来保存这些删除的数据。

标准化包括三种形式或步骤:

*   第一范式:信息存储在一个表中，每一列都包含原子值。没有重复的列组。

*   第二范式:表采用第一范式，所有列都依赖于主键。

*   第三范式:表以第二范式存储，它的所有列都不依赖于主键。

#### 第一范式

第一范式涉及检查任何列是否是任何两个或更多其他列的组合，或者是否存在具有相同或相似信息的重复列。

例如，包含两个相加在一起的其他列的列就属于这一类。事实证明，数据库很容易为一个查询执行这种计算，所以汇总列被认为是多余的。这同样适用于串联在一起形成第三列的字符串数据列。总是让数据库为您执行这种数据转换。这将防止当转换中涉及的列之一用新值更新时潜在的数据损坏。

让我们看一下包含汇总数据的表格:

```py
CREATE TABLE employee (
      VARCHAR(50) name NOT NULL,
      . . .
      DECIMAL(10,2) salary,
      DECIMAL(10,2) bonus,
      DECIMAL(10,2) total_salary,
      . . .
      );

```

创建员工时，已知`salary`和`bonus`，并计算出`total_salary`的输入。这不是第一范式，因为我们有一个包含在表中的字段是从表中的其他两个字段计算出来的。当`salary`或`bonus`被更新而`total_salary`被遗忘时，这很容易出错。这显然会导致引用完整性问题。在这种情况下，应该删除`total_salary`字段，如果以后需要该值，让数据库在查询过程中一起添加`salary`和`bonus`字段。这对查询的影响很小，并且保持了参照完整性。

我们的第二个例子涉及到在一个与主表实体不直接相关的表中保存重复的信息。以下是此类表格的一个示例:

```py
CREATE TABLE customer (
      . .
      VARCHAR(50) name NOT NULL,
      . . .
      INT ordernum1,
      INT ordernum2,
      INT ordernum3,
      . . .
      )

```

这里的想法是，为了方便起见，客户的最后三个订单与`customer`数据一起保存。这很糟糕，因为三个订单号的顺序必须保持不变。事实证明这真的很难做到。数据库可以很容易地从`order`表中提取最近的订单，所以您应该让它完成自己的工作，并从`customer`表中删除这些字段。

#### 第二范式

第二范式删除任何不依赖于表主键的列。这将防止表字段之间的任何部分依赖。例如，您不会在存储客户信息的表中存储客户订单。应该创建一个单独的`order`表来保存这些信息。毕竟，一个客户在任何时候都可能有多个有效订单。

以下是违反第二范式的一个例子:

```py
CREATE TABLE part (
      VARCHAR(50) partnum PRIMARY KEY NOT NULL,
      VARCHAR(50) warehouse PRIMARY KEY NOT NULL,
      INT quantity NOT NULL,
      VARCHAR(50) warehouse_addr NOT NULL
      )

```

在这个例子中，`warehouse_addr`不是`part`的属性。它是`warehouse`表的一个属性，所以它不属于`part`表。

#### 第三范式

第三范式有点难识别。存储患者数据的医院数据库就是一个很好的例子。如果患者表包含医生的电话号码，那么该数据不依赖于患者。该数据属于医生表。该列应该替换为对医生的键引用，而不是医生实体的属性。这就是所谓的删除可传递的依赖关系。

以下示例显示了违反第三范式如何导致引用完整性问题:

```py
CREATE TABLE employee (
      INT emp_num PRIMARY KEY NOT NULL,
      VARCHAR(20) first_name NOT NULL,
      VARCHAR(20) last_name NOT NULL,
      CHAR(10) work_dept NOT NULL,
      VARCHAR(20) dept_name NOT NULL
      )

```

如果需要更改`dept_name`(而不是`work_dept`)，那么如果您遗漏了该部门中的一个员工，那么您现在就遇到了引用完整性问题。`dept_name`属于`department`表，而不是`employee`表，因此应该删除该列。

最后要指出的是，第三范式在实现时会导致性能问题。许多数据库设计者已经将他们的设计带到了第三范式，却发现他们不得不退回到第三范式，这样数据就直接在一个不是第三范式的表中，以便为用户提供适当的性能。

#### 第四范式

还有第四种范式，但我们不会讨论它，因为它需要创建新的表来解决问题。这有时会导致用户在创建查询时感到困惑和沮丧。对于您的数据库来说，这种麻烦可能值得，也可能不值得。例外情况可能是空间非常宝贵的大型数据库，因为第四范式可以减少数据库所需的空间。

### 商业规则

设计好主表后，就该考虑自动保持表同步所需的业务规则了。此活动将简化添加和更新表的过程。几个表可能有需要维护的直接关系。如果一个新行被添加到一个表中，可能需要维护一些依赖关系。业务规则可以通过在相关表更新时自动更新/添加/删除来简化这项任务。

在这些情况下，Db2 有许多工具可以提供帮助。它们太多了，我们用了整整一章来讨论它们。参见第六章。

## 阶段 2:数据库的物理设计

一旦设计了表、索引和业务规则，就需要在一组磁盘驱动器上布置表。根据您必须使用的硬件和数据库的大小，有许多方法可以做到这一点。

一个高达几千兆字节的小型数据库可以很容易地放在单个磁盘驱动器上，而不会对性能产生重大影响。然而，随着数据库变得越来越大，任务变得越来越困难。如果您从一个小型数据库开始，并且它开始增长，那么性能就成了一个主要问题。因此，您不仅应该考虑当前数据库的大小，还需要了解其潜在增长率，并设计适当的解决方案。

在过去，当磁盘驱动器相当小并且性能受到限制时，即使是小型数据库也需要围绕磁盘驱动器的性能来设计。一个表可能需要跨越几个驱动器，以便它们可以在一个查询中异步地协同工作。如今，驱动器的容量非常大，有些甚至达到了 8tb 和 10 TB，而且还在不断增大。当心这些驱动器。仅仅因为磁盘上的寻道时间，尝试使用这些驱动器上的所有可用空间就可能会导致巨大的性能影响。

通过创建 RAID 阵列，可以在一定程度上解决大磁盘驱动器的许多问题。RAIDs 5 和 6 是相当好的替代方案，其中表中的数据可以分布在阵列中的所有驱动器上。因此，如果阵列由八个驱动器组成，那么这八个驱动器可能都负责从表中检索数据。但是这种解决方案存在潜在的问题。在早期，向阵列写入数据时会出现很大的性能问题。这些惩罚多年来已经部分取消，但在某些方面仍然存在。

RAID 6 试图消除 RAID 5 的写性能损失。在很大程度上，实现是成功的，没有增加新的损失或增加现有特性的损失。RAID 6 的主要缺点是为缓存和临时存储提供存储空间需要更大的开销。事实证明，这在今天的大型磁盘上可以完全忽略。由于其较大的尺寸，今天的磁盘可以很容易地容纳必要的开销。

大型机使用的解决方案是使用一个或一组驱动器来存储一个大的单个表。但对于中小型系统来说，这不是一个好的解决方案，因为对于今天的驱动器，驱动器上会有大量浪费的空间。

一种相对新型的驱动器可以解决这些问题。这些是固态硬盘和其他基于内存的驱动器。这些驱动器在读写方面都有出色的性能。然而，它们的尺寸仍然相对较小，并且大量购买它们的成本可能过高。但在未来，这些可能会成为许多数据库的首选驱动器，因为性能非常好。

### 备份

这是开始考虑数据库备份的时候了。不要把这个任务推迟到以后，因为那会给你带来麻烦和问题。如果您正在备份到磁盘，您将需要额外的磁盘空间来容纳它们。对于磁带，您可能需要一个专用于数据库的磁带机。数据库的大小可能决定您的备份选项。所有这些都需要在设计过程中预先考虑，而不是以后。

Db2 有一个从`db2`提示符运行的专用备份命令。如果可能，您应该使用此命令，因为它具有加密和压缩选项，并且能够执行增量备份。它有多个选项，可以在数据库、页面和表空间级别执行各种不同的备份。它可以对任何设备执行备份，只要该设备装载到文件系统中。一个例外是执行到另一个 Db2 远程数据库的备份。这可以通过到本地系统的多个连接来完成。

不要试图在规划过程中最终确定备份解决方案。这个想法是确定你的选择，并尝试选择一个可以在以后最终确定的选项。

## 摘要

本章高度概括了收集必要数据，然后对数据库执行第一级逻辑和物理设计所需的任务。我们讨论了实现这一目标的所有主要主题，并让合适的人员为此做出贡献。

应该记住，这只是一个简短的回顾。如果你真的要做这项工作，你应该查阅更多的资料。我们在这里提供的只是高级任务的指南。