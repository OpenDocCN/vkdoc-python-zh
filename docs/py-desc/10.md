# 十、描述符也是类

是时候用描述符来描述一些更高级的东西了。实际上，它并不是真正的高级，因为它适用于所有的职业。在这一章中不会有太多的深入研究；这只是提醒我们，通常可用于类的特性也可用于描述符。

## 遗产

描述符可以从其他类(通常是其他描述符或描述符工具/助手)继承和被继承。使用继承，可以使用预先构建的 mixins 和模板类来构建描述符，这些类已经实现了存储属性所需的基本功能。事实上，在下一章中会讨论到其中的一组，并且在库中有完整的提供。仅举一个例子，可以创建一个基类来处理使用描述符上存储的次要细节，派生的专门化可以将这些细节委托给它。同样，在下一章中有更多关于这个想法的内容，在库中有完整的代码示例。

## 更多方法

一个描述符可以有比描述符协议更多的方法，`__set_name__()`和`__init__()`。这表现在有后门方法的秘密描述符上，比如`set()`。

像这样的外部使用的方法应该受到限制，因为对这些方法的访问也应该受到限制，但是使用只在类内使用的内部使用的“私有”方法绝对是公平的。同样，实现`__str__()`和`__repr__()`也是一个好主意。实现`__eq__()`或`__hash__()`很少有用或必要，因为描述符本身不太可能被比较或作为关键字存储在散列集合中。

## 可选/默认参数

就像在强制设置描述符中一样，可选/默认参数可以添加到协议方法中。由于提供可选参数的用户仍然需要获得描述符对象并直接调用协议方法，这应该是有限的，就像其他外部使用的方法一样。

此外，为了组合和继承，应该对其进行限制。如果提供可选参数的类被包装或被子类化，新类要么必须知道可选参数，要么提供一个`**kwargs`参数并向下传递它，这将在库中提供的大部分代码中看到。

## 描述符上的描述符

因为描述符是类，所以描述符上也可以有描述符！有好几次我几乎这样做了，但是 setter 比描述符提供的要复杂得多，所以我不得不接受。我也考虑过使用描述符使属性成为只读的，但是我还没有完全确定下来。

## 传递实例

从来没有人说过描述符必须为它所在的每个类创建一个新的实例。描述符的实例可以在类定义之外创建，然后分配给多个类的类属性。

当存储在描述符上时，这可以节省一点空间，因为它只有一个字典的开销，而不是每个类一个。事实上，如果将值存储在描述符上，这比存储在实例上要容易得多。描述符在实例上存储值的问题是，您需要名称来存储它，如果该名称被认为与描述符在类上的名称相同或从该名称派生，您必须处理描述符有多个名称的可能性。有趣的是，每次在类定义中将描述符分配给一个类时，`__set_name__()`都会被调用。如果您不需要这个名称(对于错误消息，您应该需要)，您仍然可以在多个类上使用一个描述符。最好的用例是描述符非常具体，并且在每个类中使用相同的名称。这消除了所有的问题。

但是，如果您希望在多个类中使用描述符的单个实例，而这些类可能使用不同的名称，那么您需要为这些名称创建一个专门的存储，该存储由类控制，但也可以考虑继承。实际上，我会享受这个挑战，并考虑创建一个放入描述符工具中，但是我不想过多地鼓励这个想法。

无论如何，不要对同一个类的多个属性重复使用同一个描述符。这根本行不通。所有属性将具有相同的值。

## 描述符只是抽象的方法调用

基本上，描述符只是完成某些方法调用的一种更简单的方式。那些方法调用没有*有*以类似于`property`的方式工作，获取和/或设置某个值。

描述符方法本质上可以替换类中任何不带参数并返回对象的方法。更重要的是，它甚至不需要返回任何东西，因为不返回任何东西意味着它返回`None`。`__set__()`描述符方法可以替代任何只有一个参数并且不返回任何东西的方法。`__delete__()`方法替换没有参数的方法，并且不返回任何东西。

虽然描述符*可以以这些方式使用*，但是对于描述符的用户来说，这样做很可能是不直观的，主要是因为语法在许多情况下看起来很奇怪，尤其是在`__delete__()`的情况下。

## 摘要

任何可以用其他类完成的事情都可以用描述符来完成，包括这里没有提到的事情。虽然大部分功能可以在没有任何负面影响的情况下完成，但很多功能并不需要，但是在编写描述符时记住这些并没有坏处。