# 六、需要哪些方法？

设计描述符时，必须决定要包含哪些方法。它有时有助于立即决定描述符应该是数据还是非数据描述符，但有时“发现”它是哪种描述符会更好。

`__delete__()`很少需要，即使它是一个数据描述符。然而，这并不意味着它不应该被包括在内。如果描述符将被发布到一个开放的域中，那么在数据描述符上添加`__delete__()`方法不会有什么坏处，仅仅是为了完整性，以防用户决定对它调用`del`。如果不这样做，当有人试图删除它时，就会引发一个`AttributeError`。

数据描述符*和非数据描述符*几乎总是需要用到`__get__()`。它对于非数据描述符是必需的，而对于数据描述符不需要`__get__()`的典型情况是，如果`__set__()`将数据以与描述符相同的名称分配到实例字典中(我称之为“一劳永逸”的描述符)。否则，几乎总是需要它来检索在数据描述符中设置的数据，因此，除非数据被分配给实例以便在没有`__get__()`的情况下自动检索，或者数据是只写的，否则`__get__()`方法将是必要的。请记住，如果描述符没有`__get__()`方法，并且`instance`在`__dict__`中没有与描述符同名的内容，那么将返回实际的描述符对象本身。

就像`__delete__()`，`__set__()`只用于数据描述符。与`__delete__()`不同，`__set__()`并不被视为多余。鉴于`__delete__()`在大多数情况下是不使用的，所以`__set__()`几乎是创建数据描述符的一个需求(需要`__set__()`或`__delete__()`)。如果描述符的状态是数据还是非数据，那么`__set__()`通常是决定性因素。即使数据应该是只读的，也应该包含`__set__()`来引发`AttributeError`以加强只读特性。否则，它可能会被视为非数据描述符。

## 调用 __get__()时没有实例参数

描述符的`__get__()`方法通常是描述符上最复杂的方法，因为有两种不同的方法可以调用它:带或不带`instance`参数(尽管“不带”意味着给出的是`None`而不是实例)。

当描述符是类级别的描述符(通常是非数据)时，实现`__get__()`而不使用`instance`是微不足道的，因为这是预期的用途。但是当描述符用于实例级时，如果描述符不是从实例中调用的，就很难弄清楚该做什么。

在这里，我提出几个选择。

### 引发异常或返回自身

想到的第一件事可能是引发一个异常，因为类级别的访问是无意的，但这应该避免。Python 中一种常见的编程风格叫做*【EAFP】*，意思是比 ***p*** *权限*多一份***a****sk****f****的原始性这意味着，仅仅因为某样东西没有按预期使用，并不意味着它的使用应该被禁止。如果使用会损害不变量并导致问题，通过引发异常来禁止它是好的；否则，还有其他更好的选择可以考虑。常规的解决方案是简单地返回`self`。如果描述符是从类级别访问的，那么用户很可能意识到它是一个描述符，并希望使用它。这样做可能是不恰当使用的标志，但是 Python 允许自由，并且它的用户也应该在一定程度上允许自由。举例来说，如果从类中访问，`property`内置函数将返回`self`(`property`对象)。据我所见，这是目前最常见的方法。*

### “未绑定”属性

方法使用的另一种解决方案是返回属性的“未绑定”版本。当从类级别访问一个函数时，函数的`__get__()`检测到它没有实例，所以只返回函数本身。在 Python 2 中，它实际上返回了一个“未绑定”的方法，这就是我使用的名称的来源。但是在 Python 3 中，他们把它改成了函数，因为它本来就是函数。

这也适用于不可调用的属性。这有点奇怪，因为它将属性变成了一个必须接收实例才能返回值的 callable。这使得它成为一个特定的属性查找，类似于`len()`和`iter()`，在这里您只需要传入实例来接收想要的值。

下面是一个以这种方式工作的精简的`__get__()`实现。

```py
def __get__(self, instance, owner):
    if instance is None:
        def unboundattr(inst):
            return self.__get__(inst, owner)
        return unboundattr
    else:
        ...

```

当被调用时，内部的`unboundattr()`函数将使用`__get__()`方法的`else`分支结束(假设它们没有传入`None`)。使用内部函数有时会令人困惑，每次都键入整个内容有点烦人，所以这里有一个可重用的类实现，它可以被任何描述符使用。

```py
class UnboundAttribute:
    def __init__(self, descriptor, owner):
        self.descriptor = descriptor
        self.owner = owner

    def __call__(self, instance):
        return self.descriptor.__get__(instance, self.owner)

```

使用这个类，使用未绑定属性的`__get__()`方法可以这样实现:

```py
def __get__(self, instance, owner):
    if instance is None:
        return UnboundAttribute(self, owner)
    else:
        ...

```

最初的版本依赖于围绕`self`和`owner`的闭包，这移除了它的可重用性，而不是通过复制和粘贴。但是该类的构造函数接受这两个变量，并存储在一个新的实例中。如果你打印一个未绑定的属性对象，它说这是一个未绑定的属性，这也是一件好事。(如果您实现了自己的版本，这也是可行的，特别是如果您接受一些方便的元数据，比如被访问的属性的名称。在下一章中会有更多关于如何做的内容。)

这项技术真正有趣(并且有用)的地方在于，未绑定属性可以传递给接收函数的高阶函数，比如`map()`。它避免了编写 getter 方法或难看的 lambda。例如，如果有这样一个类:

```py
class Class:
    attr = UnbindableDescriptor()

```

对一列`Class`对象的`map()`调用如下:

```py
result = map(lambda c: c.attr, aList)

```

可以替换为:

```py
result = map(Class.attr, aList)

```

没有传入 lambda 来完成访问`Class`实例的属性的工作，而是传入了`Class.attr`,它返回属性的“未绑定”版本——一个接收实例的函数，以便在描述符上查找属性。本质上，描述符提供了一个隐式的 getter 方法来引用属性。

对于实现描述符的`__get__()`方法来说，这是一种非常有用的技术，但是它有一个主要缺点:返回`self`是如此普遍，以至于不这样做是非常意外的。希望这个想法在社区中得到一些支持，并成为新的标准。此外，正如在下一章只读描述符中看到的，可能需要一种方法来访问描述符对象。幸运的是，您需要做的就是从返回的`UnboundAttribute`中获取`descriptor`属性。

尽管这不是预期的行为，但内置的`function`描述符已经做到了这一点，所以对他们来说习惯这一点不会太难。当从类级别访问时，人们期望“未绑定的方法”函数，所以对他们来说，将约定应用于属性应该不是很难。

自从写了这本书的第一版，我就发现标准库中有一个创建未绑定属性的函数，在某些重要的方面比`UnboundAttribute`更有用。在`operator`模块中，有一个名为`attrgetter()`的函数，它接受一个属性的字符串名称并返回一个函数，该函数接受一个实例并(我假设)用属性的名称在实例上调用`getattr()`。还支持传入多个属性名；最终结果是实例上所有这些属性的元组。

与基于描述符的未绑定属性相比，这有几个显著的好处(甚至不考虑多属性支持)。首先是对继承的更大支持。如果一个子类用不同的描述符覆盖了描述符，但是超类版本被传递，它实际上将使用超类描述符，这就消除了继承的令人敬畏的动态特性。出于同样的原因，除非你完全确定你正在使用的类没有任何子类，否则你也应该对方法使用`attrgetter()`。

基于描述符的未绑定属性可以支持相同级别的继承支持，但是需要做更多的工作。首先，您需要属性的名称，这并不总是很容易得到。同样，这样做的方法在下一章。在那之后，改变是非常简单的。你把`__call__()`改成用`getattr()`而不是`descriptor.__get__()`。这就消除了对`descriptor`和`owner`属性的需要，尽管您应该保留`descriptor`以便有人可以查找描述符，如前所述。遗憾的是，我看不到任何支持多属性的可行方法。

第二个主要好处是它适用于所有类型的属性，而不仅仅是方法或基于描述符的属性。

然而,`attrgetter()`也有一些缺点。首先，也可能是最明显的，是缺少代码完成帮助。您正在传递一个属性的字符串名称，这意味着无论您使用什么编辑器都不会帮助您避免属性名称的拼写错误。第二，它失去了一点点上下文。当使用类名时，您包括属性名适用的上下文，而`attrgetter()`只包括属性名。

如果你升级到`UnboundAttribute`，我仍然完全支持使用它。但是知道什么时候使用`attrgetter()`当然是好的。

## 摘要

我们已经研究了构建通用描述符背后的决策过程，并弄清楚我们需要哪些方法，以及可能使用带有`__get__()`的未绑定属性。在下一章中，我们将深入探讨更多必须做出的设计决策，至少在用描述符存储值时。