# 七、存储属性

既然所有的准备工作都已经完成了，是时候看看描述符中有用的部分了:存储描述符所代表的属性。用描述符存储属性有很多种方法，本章将从最简单的开始，介绍我所知道的每一种方法。

## 类别级存储

类级存储很容易；它是描述符上的正常存储。例如，下面是创建基本类级变量的描述符:

```py
class ClassAttr:
    def __init__(self, value):
        self.value = value

    def __get__(self, instance, owner):
        return self.value

    def __set__(self, instance, value):
        self.value = value

```

这个描述符将一个值保存在自身上作为典型的实例属性，这个值只是在`__get__()`方法中返回，不管是否提供了`instance`，因为它是一个类级别的属性。也可以通过实例访问该属性，但是从实例对其进行任何更改都会将更改应用到该类的每个实例。不幸的是，由于从类级别访问描述符时没有调用`__set__()`，存储描述符的变量将被重新赋值给新值，而不是传递给`__set__()`。

关于制作可以使用`__set__()`和`__delete__()`的类级描述符的更多细节，请查看本章末尾关于元描述符的部分。

然而，描述符不仅仅用于类级别的属性；它们也用于实例级属性。使用描述符存储实例级属性有两种主要策略:

*   在描述符上

*   在实例字典中

对于可重用的描述符，每种策略都有一些障碍需要清除。当将它存储在描述符上时，如何在没有内存泄漏或散列问题的情况下存储它存在障碍。至于在实例字典中存储属性，困难在于试图找出在字典中以什么名称存储属性以避免冲突。

## 在描述符上存储数据

如前所示，在描述符上保存一个简单的值就是类级别值的存储方式。要在一个地方存储每个实例的值，必须做什么？所需要的是某种将实例映射到其属性值的方法。映射的另一个名字是字典。也许字典会有用。下面是使用字典进行存储的样子。

```py
class Descriptor:
    def __init__(self):
        self.storage = {}

    def __get__(self, instance, owner):
        return self.storage[instance]

    def __set__(self, instance, value):
        self.storage[instance] = value

    def __delete__(self, instance):
        del self.storage[instance]

```

`__get__()`方法不处理`if instance is None`的情况，在所有其他例子中，为了简洁和消除阅读代码时的干扰，它将被忽略。

代码示例中的`dict`已经解决了每个实例的第一个存储问题。不幸的是，使用普通的老式`dict`有几个缺点。

要解决的第一个缺点是内存泄漏。一个典型的`dict`将在对象因未被使用而被垃圾收集后很久才存储用作键的实例。这对于不会使用大量内存的短命程序来说很好，如果实例不会遭受后面提到的第二个缺点，但如果不是这样，我们需要一种方法来处理这个问题。

让我们看看如何解决这个问题。描述符需要一种方法来停止关心不再使用的实例。`weakref`模块正好提供了这一点。弱引用允许变量引用一个实例，只要在某个地方有一个对它的正常引用，否则允许它被垃圾收集。它们还允许您指定移除引用后立即运行的行为。

该模块还提供了几个集合，这些集合被设计为在项目被垃圾回收时从自身移除项目。其中，我们想看一个`WeakKeyDictionary`。一个`WeakKeyDictionary`保存了一个对它的键的弱引用，因此一旦被用作键的实例不再被使用，字典就会清除整个条目。

所以，这又是一个例子，这次使用了`WeakKeyDictionary`。

```py
from weakref import WeakKeyDictionary
class Descriptor:
    def __init__(self):
        self.storage = WeakKeyDictionary()

    def __get__(self, instance, owner):
        return self.storage[instance]

    def __set__(self, instance, value):
        self.storage[instance] = value

    def __delete__(self, instance):
        del self.storage[instance]

```

前一个例子和这个例子之间的每一个变化都被加粗了，这表明实际上没有太大的区别。唯一的区别是需要导入特殊的字典，并且需要创建一个`WeakKeyDictionary`而不是普通的`dict`。这是一个非常容易的升级，许多描述符指南到此为止。它在大多数情况下都有效，所以这是一个不错的解决方案。

不幸的是，它仍然有常规`dict`的另一个缺点:它不支持不可销毁的类型。

要使用一个对象作为`dict`中的键，它必须是可散列的。有一些内置类型不能被散列，即可变集合(`list`、`set`和`dict`)，也许还有更多。任何可变的对象(内部的值可以改变)和覆盖`__eq__()`来比较内部值的对象必须是不可改变的。如果对象以改变相等性的方式被改变，散列码突然改变，使得它不能作为字典键被查找。因此，通常建议这样的可变对象使用`__hash__ = None`将自己标记为不可改变的。覆盖`__eq__()`将自动执行此操作；因此，仅当相等不变时，才应覆盖`__hash__`。

如果不是 Python 提供了默认的实现`__eq__()`和`__hash__() (`相等与相同——一个对象等于它自己，而不是其他),大多数对象都不会是可散列的，因此支持使用散列集合的描述符。幸运的是，这意味着默认情况下类型*是*可散列的，但是仍然有许多不可散列的类型。

还是那句话，`WeakKeyDictionary`是*而不是*一个糟糕的解决方案；只是没有涵盖所有的可能性。大多数时候，它已经足够好了，但是它通常建议不要将它用于公共库，至少在文档中没有好的警告的情况下是这样的。毕竟，描述符协议提供了设置和删除属性的方法，所以它们应该支持可变类的实例。

需要有一个不受这个问题困扰的解决方案，而且确实有。最简单的解决方案是使用`instance`的 ID 作为键，而不是实例本身。万岁！现在字典不再保留未使用的`instance`,也不要求类是可散列的。

这是解决方案的样子。

```py
class Descriptor:
    def __init__(self):
        self.storage = {}

    def __get__(self, instance, owner):
        return self.storage[id(instance)]

    def __set__(self, instance, value):
        self.storage[id(instance)] = value

    def __delete__(self, instance):
        del self.storage[id(instance)]

```

该示例切换回正常的`dict`，因此提到的更改是基于该示例与第一个示例之间的差异，而不是与前一个示例进行比较。每次访问存储时，都是由`id(instance)`而不仅仅是`instance`来访问。

这似乎是一个很好的解决方案，因为它没有前两个解决方案的任何一个问题。但这不是一个好的解决方案。它不会遇到与以前的解决方案完全相同的问题，但它仍然会遇到内存泄漏。是的，字典不再存储实例，所以不会保留这些实例，但是没有机制可以从字典中清除无用的 id。事实上，有一种可能性(这种可能性很小，但确实存在),该类的一个新实例可能是用一个已删除的旧实例的相同 ID 创建的，因此新实例的属性与旧实例的属性相同，直到它被更改。那是假设*可以*改变；如果描述符被设计成只读的(后面会有更多介绍)会怎么样？那么新实例就完全被旧值卡住了。

所以，这仍然没有解决描述符上的存储问题，但是它朝着正确的方向发展了。我们需要的是一个像字典一样工作的存储系统，以`instance`为键，但使用`id(instance)`而不是`hash(instance)`进行存储。如果实例不再被使用，它还需要清理自己。

因为这样的东西不是内置的；它必须是定制的。这是专门为这本书设计的自定义词典。

```py
import weakref

class DescriptorStorage:
    def __init__(self, **kwargs):
        self.storage = {}
        for k, v in kwargs.items():
            self.__setitem__(k, v)

    def __getitem__(self, item):
        return self.storage[id(item)]

    def __setitem__(self, key, value):
        self.storage[id(key)] = value
        weakref.finalize(key, self.storage.__delitem__, id(key))

    def __delitem__(self, key):
        del self.storage[id(key)]

```

现实版显然方法更多，比如`__iter__`、`__len__`等。，但是这里实现了带描述符的存储的三个主要用途。其余的实现可以在描述符工具库中找到。

这个类出奇的简单。它的基础是有一个 facade 类，它的作用就像一个字典，将大多数功能委托给一个内部字典，但是将给定的键转换成它们的 id。唯一真正的区别是，在`__setitem__()`中，这个新类创建了一个`finalize`弱引用，当引用被垃圾收集时，它接受一个引用、一个函数和任何要发送给那个函数的参数。在这种情况下，它从内部字典中删除该项(同样，使用`id()`存储)。

这个存储类如何工作的关键是使用一个 ID 作为键(这意味着实例不需要是可散列的)和弱引用回调(从字典中删除未使用的对象)。本质上，这个类是一个`WeakKeyDictionary`，它在内部使用给定键的 ID 作为实际键。

将属性安全地存储在描述符中比大多数人实际考虑的要多得多，但是现在有一个很好的、包罗万象的解决方案可以做到这一点。前两种解决方案并不完美，但并非毫无用处。如果描述符的用例允许使用这两种解决方案中的任何一种，那么考虑它们也无妨。它们在很多情况下都是可行的，并且可能比这里提供的定制存储系统的性能略高。但是，对于公共库，应该考虑定制字典或下一节中的实例解决方案。

### 存储在实例字典中

如果能够找到一个有价值的策略来导出键，那么将数据存储在实例上比存储在描述符中更好。这是因为它不需要额外的存储对象；使用`instance`的内置存储字典。然而，一些类将定义`__slots__`，因此，不会有存储字典来捣乱。这在一定程度上限制了实例策略的有用性，但是`__slots__`很少使用，几乎不值得考虑。

如果您希望使用`__slots__`使描述符安全，同时仍然默认使用实例字典，那么您可能希望创建某种替代方法，在创建时设置一个布尔标志，使用描述符上的存储。有很多方法可以实现这一点，无论是使用工厂选择不同的描述符(如果设置了标志)还是其中的类具有基于标志值的替代路径。另一个更简单的方法是记录描述符存储其值的名称，以便想要使用`__slots__`的描述符用户可以为它准备一个槽。这要求描述符直接进行实例属性设置(要么用点符号，要么用`getattr()`、`setattr()`和`delattr()`)，而不是先获取实例字典。

另一种解决方法(不需要明确询问用户)是检查类是否有存储字典；如果有，就简单地使用它，但是如果没有，可以直接存储在描述符实例上。检查`__slots__`的存在是不可靠的，因为子类可能没有定义`__slots__`(而基类有)，所以它们既有实例字典又有`__slots__`。

使用实例字典在实例上存储数据很容易(尽管通常很冗长，因为为了避免递归调用描述符，通常需要引用属性为`vars(a)['x']`而不是`a.x`)，如下例所示。这是一个简单的例子，存储数据的位置被硬编码为`"desc_store"`。

```py
class InstanceStoringDescriptorBasic:
    name = "desc_store"

    def __get__(self, instance, owner):
        return vars(instance)[self.name]

    def __set__(self, instance, value):
        vars(instance)[self.name] = value

    def __delete__(self, instance):
        del vars(instance)[self.name]

```

如图所示，在实例上存储非常容易。不过，你们有些人可能不知道`vars()`，所以我来解释一下。在对象上调用`vars()`会返回实例字典。你们中的许多人可能知道`__dict__`。`vars()`函数返回相同的字典，并且是访问它的首选方式(读“Pythonic”)。这是首选，主要是因为缺少双下划线。像几乎所有其他带有双下划线的“神奇”属性一样，使用它有一种简洁的方式。希望现在你能告诉你所有使用 Python 的伙伴，这将成为一个更广为人知的功能。

但是为什么要通过`vars()`而不是简单的点符号来访问这些值呢？实际上，在很多情况下，使用点符号也能很好地工作。事实上，它在大多数情况下都有效。唯一出现问题的时候是当数据描述符与字典中用于存储的名称相同，或者使用的名称不是合法的 Python 标识符。通常，出现这种情况是因为描述符有意将属性存储在自己的名称下，这几乎可以保证防止名称冲突。但是仍然有可能外部数据描述符与主描述符试图存储其数据的位置同名。为了避免这种情况，最好总是直接引用实例的字典。另一个很好的理由是，它使数据存储在哪里变得更加明确和明显。

接下来要弄清楚的是描述符如何知道存储属性的名称。希望很明显，硬编码位置是一个坏主意；它防止在同一个类上使用该类型描述符的多个实例，因为它们都将争用同一个名称。

### 询问位置

获取位置名称的最简单方法是在构造函数中请求它。这样的描述符应该是这样的:

```py
class GivenNameInstanceStoringDescriptor:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance.__dict__[self.name]

```

这一个与前一个唯一的真正区别是它有一个`__init__()`方法，该方法从用户那里接收首选的位置名称，而不是硬编码它。实际上，代码的其余部分完全相同。

在创建描述符时，请求存储属性值的位置很容易，但是对于用户来说很繁琐，甚至在要求位置与描述符同名的情况下很危险，因为用户可能会搞砸。这就是“一劳永逸”描述符的情况，例如下面的描述符，它是一个使用所提供的函数来验证数据的描述符。

```py
class Validated:
    def __init__(self, name, validator):
        self.name = name
        self.validator = validator

    def __set__(self, instance, value):
        if self.validator(value):
            instance.__dict__[self.name] = value
        else:
            raise ValueError("not a valid value for" + self.name)

```

在这个`Validated`描述符中，`__init__()`请求存储实际数据的位置。因为这是一个“一劳永逸”的描述符，它让实例处理检索，而不是提供一个`__get__()`，所以用户提供的位置必须与描述符在类中的名称相同，以便描述符能够按预期工作。例如，如果一个类被意外地写成这样:

```py
class A:
    validatedAttr = Validated('validatedAttribute', validatorFunc)

```

全都搞砸了。为了设置它，用户写`a.validatedAttr = someValue`，但是检索它需要用户写`a.` `validatedAttribute`。这看起来并没有那么糟糕，因为它可以很容易地修复，但是这些类型的错误通常很难发现，并且可能需要很长时间才能注意到。此外，当可以以某种方式导出位置时，为什么要要求用户写入位置呢？

#### 一劳永逸的描述符

现在，一劳永逸的描述符终于可以得到解释了。在描述符协议的三种方法中，这些描述符通常只实现`__set__()`，如示例所示。然而，情况并非总是如此。例如，下面的惰性初始化描述符只使用了`__get__()`。

```py
class lazy:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        value = self.func(instance)
        instance.__dict__[func.__name__] = value
        return value

```

这个惰性描述符也可以作为一个函数的装饰器，它代替并用来进行惰性初始化。在这种情况下，以及在其他“一劳永逸”的描述符的情况下，描述符直接将值设置到实例上，使用描述符引用的相同名称。这允许描述符要么是从不使用超过一次的非数据描述符——如在`lazy`的情况下——要么是不需要实现`__get__()`的数据描述符，这是大多数“一劳永逸”描述符的情况。在许多情况下，一劳永逸的描述符可以通过查看实例来提高查找速度，甚至提供其他优化，如`lazy`描述符。

## 间接询问位置

关于“一劳永逸”部分中的`lazy`描述符，还可以注意到其他一些东西，这就是它如何能够确定在哪里存储属性；它把它从它所修饰的函数中提取出来。

这是间接询问描述符名称的好方法。由于描述符被初始化为一个装饰器，提供了一个描述符要替换的函数，它可以使用这个函数的名字来查找这个名字来存储关于`instance`的信息。

### 名字叫莽林

但是，像这样直接使用名称对于大多数非数据描述符来说是危险的，因为直接将它设置到那个位置会覆盖它自己的访问(这是`lazy`实际上想要发生的)。当构建不想覆盖自身的非数据描述符时——尽管出现这种情况的可能性很小——最好在存储数据时进行一些“名称篡改”。为此，只需在名称的开头添加一两个下划线。使用至少两个前导下划线和最多一个尾随下划线会导致 Python 在名称中添加自己的 mangling 使用一个前导下划线只是表明该属性对于使用该对象的人来说是“私有”的。这个名字已经在`instance`上被占用的可能性极低。

接下来，如果向用户询问名称是个坏主意，并且描述符也不是装饰符，该怎么办？那么描述符是如何决定它的名字的呢？有几个选项，第一个将被讨论的是描述符如何试图挖掘它自己的名字。

#### 获取名称

查找描述符的名称似乎很简单，但是，像任何对象一样，描述符可以被分配给多个不同名称的变量。不，需要一种更迂回的方式来发现自己的名字。

### 注意

这项技术的灵感来自于 YouTube 上的“滑索秀”，特别是他们关于描述符 <sup>3</sup> 的视频。这项技术在 22 分钟后出现。他们可能从他们在视频开头提到的书里学到了技巧，但是我从他们那里学到了这个想法，而不是这本书。

我稍加修改的这种技术的原始版本使用了下面的代码。

```py
def name_of(self, instance):
    for attr in type(instance).__dict__:
        if attr.startswith('__'): continue
        obj = type(instance).__dict__[attr]
        if obj is self:
            self.name = self.mangle(attr)
            break

```

这个方法可以添加到任何描述符中，以便查找它的名称。如果描述符的`name`属性没有设置，描述符就运行这个方法来设置它。在倒数第二行，它将名称发送到一个名称处理器——它只是确保名称以两个下划线开头——而不是使用原来的名称。正如在名称篡改一节中提到的，这可能是必要的，但并不总是如此。

不过，这种方法有一个问题:它不处理子类。如果一个具有这个描述符的类被子类化，并且该子类的一个实例试图在原始类的一个实例之前使用该描述符，那么它将无法查找它的名称。这是因为描述符在原始类上，而不是在子类上，但是`name_of()`方法在类的字典中查找自己。子类的字典中没有描述符。

不过，别担心。库中的版本解决了这个问题，它使用`dir()`来获取所有属性的名称，包括来自超类的名称，然后它将这些名称委托给一个函数，该函数深入研究 MRO 上每个类的`__dict__`，直到找到它所寻找的内容。我还删除了名称篡改功能，允许您仅在必要时使用它。最后，它不会忽略以双下划线开头的属性。这种检查实际上可能比访问属性和比较身份要慢，但即使不是这样，它在很大程度上只会使代码变得混乱。另外，你永远不知道；你的描述符可以用来代替一个特殊的方法。

最终结果如下所示:

```py
def name_of(descriptor, owner):
    return first(attr for attr in dir(owner)
                 if (get_descriptor(owner, attr) is descriptor))

def first(iter):
    return next(iter, None)

def get_descriptor(cls, descname):
    selected_class = first(clss for clss in cls.__mro__
                           if descname in clss.__dict__)
    return selected_class.__dict__[descname]

```

Python 3.2 还在 inspect 模块中添加了一个名为`getattr_static()`的新函数，它的工作方式与`getattr()`类似，只是它不会在查找时激活描述符的`__get__()`方法。你可以用`getattr_static()`代替对`get_descriptor()`的调用，效果是一样的。

##### __set_name__()

在 Python 3.6 中，添加了一些东西 *else* ，使得获取名称更加容易！Python 在其协议中获得了一个额外的可选方法:`__set_name__()`。在创建包含描述符对象的类的过程中调用这个新方法。其参数为`self`、`owner`和`name`。第一个，`self`，超级明显；这是所有方法都有的第一个参数。您应该认识到第二个是描述符所在的类`owner`。最后一个，`name`，显然也是我们要找的名字；存储描述符对象的变量的名称。

### 存储原始文件和受损文件

当存储用于描述符的名称时，通常最好同时存储原始名称*和损坏的名称*。保留损坏的名称是显而易见的，但是为什么还要存储原来的名称呢？查看错误消息。如果在尝试使用描述符时出现问题，您至少需要向用户提供属性的名称，以便更好地了解问题出在哪里。

#### 键入 ID

为了在实例上存储相对安全的位置，可以做的另一件事是使用描述符的`id()`以某种方式在实例上生成一个位置。这看起来很奇怪，但是一个非字符串*可以被*用作实例字典中的键。

不幸的是，它只能通过`vars(instance)[id(desc)]`直接访问，而不能通过点符号或`get` / `set` / `hasattr()`访问。这实际上似乎是一个优点，因为它防止了对属性的不必要的访问，但是它也搞乱了`dir(instance)`，当它发现一个非字符串键时会引发一个异常。

有利的一面是，这个位置不可能与用户定义的属性冲突，因为那些属性必须是字符串，而这是一个整数。但是导致`dir()`失败是不可取的，所以必须找到不同的解决方案。定义一个`__dir__()`方法在大多数情况下是多余和不合适的。然而，激进的程序员可以调用`object.__dir__()`并在返回之前从列表中删除`id()`。然而，如上所述，这是矫枉过正。

一个简单的解决方案是将 ID 改为一个字符串，即`str(id(desc))`而不仅仅是`id(desc)`。这修复了`dir()`问题，也开放了`get` / `set` / `hasattr()`的使用，同时仍然防止点符号访问，因为它是一个无效的 Python 标识符。名称冲突的可能性仍然非常低，因此这仍然是一个可以接受的解决方案。

### 注意

`str(id(desc))`的一个有趣的小改动是使用十六进制值，作为`hex(id(desc))`而不是数字的直串版本，最好去掉开头的`'0x'`，比如`hex(id(desc))[2:]`。这样做的好处是十六进制字符串通常会更短，这将计算哈希值(在`__dict__`中查找和赋值)所需的时间缩短了一点点。是的，计算十六进制值所需的时间比计算普通字符串值所需的时间长，但是只需要做一次(您可以保存十六进制字符串供以后使用)，而属性查找可能会发生多次。这是一个微小的优化，甚至可能不值得注意。

没有充分的理由在键的前面添加可接受的字符来支持点符号，因为点符号要求用户提前知道名称是什么，这是他们无法知道的，因为当使用`id()`来派生它时，程序每次运行时名称都会改变。持续变化的键还会带来其他限制，其中之一是它会使序列化和反序列化(分别用`pickle`模块完成的 pickle 和 unpickling 是其中一种方法)变得更加困难。

如果希望能够从保存位置获得某种信息，可以将附加信息添加到键中。例如，描述符的类名可以添加到键的前面，例如`type(self).__name__ + str(id(self))`。这为使用`dir()`查看实例名称的用户提供了一些线索，让他们知道这个名称指的是什么，尤其是如果有多个描述符将它们的名称基于实例上的`id()`。

#### 让用户来照顾它

这一节的标题听起来像是在向用户询问描述符构造函数中的名称，但事实并非如此。相反，这指的是`property`使用的方法。

有人可能会说`property`“欺骗”是通过简单地将你赋予它的功能分配给它不同的方法。它作为终极描述符，几乎可以无限地定制，这就是它的本质。descriptor-y 不能做的最大的事情是成为非数据描述符(因为它定义了描述符协议的所有三个方法)，这很好，因为这不符合它的意图。此外，提供给描述符的函数不容易访问描述符的内部，所以在那里可以做的事情是有限的。

有趣的是，很大一部分描述符可以用`property`来编写——而且实际上效果更好，因为在确定数据保存位置时不会有困难——但是它确实有很大的缺陷。其中最大的问题是在重用相同的描述符时缺乏*干涩*。(不要重复自己；干燥是缺乏不必要的重复代码。)如果相同的代码需要用`property`重写很多次才能达到相同的效果，那么就应该把它变成一个封装了重复部分的自定义描述符。遗憾的是，由于要存储一个值，这不太可能是一个真正容易的复制。但是，如果描述符不需要搞清楚这一点(有时就是这样)，那么转换就容易多了。

总之，`property`是一个高度通用的描述符，它甚至使一些事情变得非常简单(也就是这一整章所要讲述的困难的事情)，但是它不容易重用。自定义描述符是最好的解决方案，这也是这本书存在的原因！

以`property`的方式重新创建“存储”的用例并不多，但是有足够多的用例以微小的方式扩展了属性的功能，值得一试。

#### 元描述符

描述符的限制和它们在类中的使用可能会很麻烦，限制了描述符的一些可能性，比如类常量。事实证明,*有*可以绕过它，这个解决方案在本书中将被亲切地称为元描述符(希望这个想法和名称能够在整个高级 Python 社区中传播)。

之所以称它们为元描述符，是因为描述符不是存储在类中，而是存储在元类中。这导致元类取代了`owner`，而类取代了`instance`。从技术上讲，这就是元描述符的全部内容。甚至不要求描述符为了成为元描述符而进行特殊设计。

虽然元描述符的概念实际上非常简单，但是元类的限制使得元描述符的使用更加困难。必须注意的最大限制是，任何类都不能从一个以上的元类派生，无论是直接在类上指定，还是多个子类有不同的元类。不要忘记，即使没有指定元类，一个类仍然是从`type`元类派生出来的。

因此，选择使用元描述符时必须小心。幸运的是，如果代码库遵循组合优先于继承的原则，这就不太可能成为问题。

关于元描述符的一个很好的例子，请看下一章末尾的`ClassConstant`元描述符。

## 摘要

在这一章中，我们看了很多在描述符中存储值的技术的例子，包括在描述符和实例本身上存储的选项。现在我们知道了适用于大多数描述符的基础知识，我们将开始研究一些其他相对常见的功能以及如何实现它。