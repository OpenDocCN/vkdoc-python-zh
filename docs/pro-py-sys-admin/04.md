# 四、将 IP 地址应用与 DHCP 集成

在前一章中，我们实现了一个简单的 IP 记账应用，允许用户跟踪他们的 IP 地址资产。我描述了应用的整个生命周期，从需求收集到设计阶段，最后到实现。重点是需求和设计阶段的重要性，因为这允许开发者验证其实现。

您可能已经注意到，尽管我们实现了大部分的初始需求，但是我们并没有得到所有的需求！我故意漏掉了几个，比如搜索功能，DNS 解析，主动检查。我这样做主要是为了演示验证您的实现并显示其中缺少的东西是多么容易，但也只是为了将章节保持在可管理的大小，而不是让信息淹没您。

因此，在本章中，我们将实现缺失的组件，并通过添加对 DHCP 服务的支持来扩展原始设计的新功能。

扩展设计和要求

我在前一章提到了“支持 DHCP”作为一个需求，但是我们真正想要的是什么呢？让我们看看 DHCP 在一个典型的组织中是如何使用的。我将假设 ISC DHCP 服务，它在大多数 Linux 发行版中广泛可用。

在子网中分配地址时，我们有以下选项:

*   静态分配 IP 地址，在这种情况下，我们为每台设备配置自己的 IP 地址。
*   根据使用 DHCP 服务的一组规则，动态分配 IP 地址。

![Image](img/00010.jpeg) **提示**在继续本章之前，您可能需要安装 ISC DHCP 服务器软件包。您可以通过使用 Linux 发行版中可用的软件包管理器来实现这一点(在 RedHat Linux 上，可以使用命令 yum install dhcp 来实现，或者在基于 Debian 的系统上，可以使用 apt-get install isc-dhcp-server)。或者，你可以从 http://www.isc.org/software/dhcp 的 ISC DHCP 官方网站下载。

让我们快速回顾一下 DHCP 能做什么以及它是如何配置的。ISC DHCP 允许您定义非常复杂的规则集。最简单的集合根本不包含任何规则，在这种情况下，假设地址池中有可用的空闲 IP，那么对 IP 的任何请求都将被准许，并且从可用池中分配一个唯一的地址。

一个常用的规则是根据硬件 MAC 地址分配 IP 地址。这种方法允许您始终为同一台机器分配相同的 IP 地址，但不要求在服务器上进行本地配置。我们可以使用 DHCP group 指令来配置这样的主机:

```py
group {
    ...
    host host001 {
        hardware ethernet 00:11:22:33:44:55;
        fixed-address 192.168.0.1;
    }
    ...
}
```

客户端分组的一种更高级的用法是 DHCP 客户端类别分离，通过这种方法，客户端被分组到满足某些标准的类别中。ISC DHCP 服务器为这种分离提供了许多选项。例如，您可以使用各种 DHCP 请求字段(甚至是它们的一部分)来对节点进行分组，例如使用 DHCP 主机名的一部分来标识发送请求的内容。您还可以通过阅读 dhcp-options 的 UNIX 手册页来了解哪些 DHCP 选项可用。以下示例使用 DHCP 选项 vendor-class-identifier 将所有 Sun Ultra 5 计算机归为一类:

```py
class "sun-ultra-5" {
    match if option vendor-class-identifier "SUNW.Ultra-5_10";
}
```

对于第二个示例，此代码匹配 DHCP 主机名的开头，如果它以“server”开头，则将其放入单独的类中:

```py
class "server" {
    match if substring (option hostname, 0, 6) = "server";
}
```

为了简单起见，让我们假设所有子网都在 DHCP 服务器上的同一个物理网络上，这意味着我们在定义新子网时将使用 shared-network 指令。

正如您所看到的，简单的调查过程正逐渐演变为做出某些设计决策。这种任务模糊的情况应该尽可能避免，我在这里展示它只是为了说明为了适应任何特定产品的限制(或特性)而改变设计是多么容易。

首先，让我们忽略我们所知道的关于特定 DHCP 服务器产品的一切，列出我们希望它做的所有事情。我们想象中的组织有多个网络，这些网络被细分为更小的子网，而这些子网又可以包含更小的子网。通常，如果子网被细分为更小的网络，它很少包含物理(或虚拟)主机的 IP 地址。这种网络中存在的唯一 IP 是网络设备的 IP 地址，如路由器、交换机和负载平衡器，它们都不是从 DHCP 获得 IP 的。因此，我们将只创建 DHCP 管理的子网，这些子网位于子网树的底部，不会细分为更小的网络。

在 DHCP 管理的网络中，我们希望有以下内容:

*   完全不受 DHCP 服务器控制的静态分配的地址。换句话说，DHCP 服务器应该不知道该范围，并且不应该配置为提供该范围内的任何地址。每个 IP 地址都是在使用它的设备上手动配置的。
*   DHCP 服务器分配的静态地址。例如，我们希望根据请求者的 MAC 地址提供 IP 地址。
*   根据客户端的属性(如硬件供应商、DHCP 参数值等)分配 IP 地址。因为我们确实知道我们需要多少 IP 地址，所以我们必须能够分配一个预定义的地址范围。我们也不希望仅仅局限于一组 DHCP 选项；我们应该完全控制所有可能的选择。
*   分配给所有其他客户端的 IP 地址。和前面的需求一样，我们需要能够指定在这里使用的 IP 范围。

正如您所看到的，列出的需求与前面列出的非常相似，但是它们不包含任何对特定实现的引用。这种方法有两个主要优点:您可以自由选择任何您认为最适合该目的的产品，并且您可以将实现外包给其他团队。只要结果满足要求，我们并不真正关心技术实现细节。此外，拥有这份清单有助于你快速识别和选择合适的产品。

除了网络管理和 IP 分配要求，我们还有一些运营需求:

*   我们需要生成配置，但不是立即应用，这样就可以手动检查和应用更改。
*   我们不需要将对配置文件的手动更改传播回应用数据库。例如，如果我们手动将一些主机添加到 DHCP 配置中，我们不需要应用相应地更新数据库条目。
*   在这个阶段，我们不希望应用控制 DHCP 服务；这将使用标准操作系统命令手动完成。

现在我们已经确定了需要什么，我们可以开始制定基本的设计决策:

*   我们将使用 ISC DHCP，因为它允许我们实现所有列出的要求。
*   我们将使用相同的 web 应用框架和语言，因为这个项目是另一个项目的扩展。
*   配置文件将由同一个 web 应用生成(也就是说，没有从数据库读取并生成配置文件的外部工具)。

正如前面的例子一样，我们现在需要做两件事:定义扩展数据模型和创建应用工作流。

扩展数据库模式

这一次，数据模型比我们只需要收集网络和 IP 地址信息时要复杂得多。现在我们需要存储 DHCP 服务器的网络拓扑视图，包括每个 DHCP 子网内的所有分类规则和地址范围。因此，我们将把它分解成定义 DB 模型类、编写视图函数和测试的几个迭代。这种渐进的方法更容易处理，我们也更容易发现错误。

目前，我们只确定了我们将拥有以下数据模型类:

*   DHCP 网络，指向它的“赞助商”网络类别。这只能为没有任何子网的网络创建。
*   地址池模型，它定义了 DHCP 网络中的地址范围，并且必须有相关的规则。
*   规则模型，定义了对 DHCP 请求进行分类的规则。每个规则可以分配给一个或多个地址池。
*   “静态”DHCP 地址规则模型，允许根据请求者的硬件 MAC 地址分配 IP。

向工作流程添加内容

工作流程中还有一些额外的东西。首先，我们需要添加一个链接，为每个没有子网的网络创建(或删除)DHCP 网络。我们还需要允许用户添加和删除关于 DHCP 网络池、规则和静态 IP 地址的信息。这些选项中的每一个都可以在 DHCP 网络列表中找到。

添加 DHCP 网络数据

在第一次迭代中，我们将添加对 DHCP 网络定义的支持。我们将使用一种类似于大型项目的方法:定义数据模型，定义工作流，然后进入实现阶段。

数据模型

让我们从添加一个新数据类开始，它将存储关于 DHCP 网络的信息。该类将指向其“赞助商”物理网络类，并包含客户端所需的几个 DHCP 选项，如路由器地址、DNS 服务器和域名。清单 4-1 展示了我们将要添加到 models.py 文件中的内容。

***清单 4-1*** 。DHCP 子网的数据模型类别

```py
class DHCPNetwork(models.Model):
    physical_net = models.OneToOneField(NetworkAddress)
    router = models.IPAddressField()
    dns_server = models.ForeignKey(DNSServer)
    domain_name = models.ForeignKey(DomainName)

    def __unicode__(self):
        return "DHCP subnet for %s" % physical_net
```

在本例中，我们还引用了两个新实体: DNSServer 和 DomainName。它们的类也在 models.py 中定义，它们只包含关于 DNS 服务器的 IP 和域名的信息以及简短的注释。将它们与 DHCPNetwork 类分开的原因是，如果我们想要更改 DNS 服务器的 IP 地址，我们不需要遍历每个 DHCP 网络条目并进行更改。您可以在 Apress 网站上的源代码中找到其他类的定义。

其他工作流程

通用 DHCP 网络支持需要哪些额外的工作流？显然，我们希望在子网中添加或删除一个 DHCP 网络，假设该子网可以有一个相应的 DHCP 网络。定义了 DHCP 网络后，我们还想修改它的设置。与前一章一样，每个工作流操作都有自己的视图功能，添加和修改也有自己的数据输入表单。正如您已经知道的，除非在 URL 配置文件中定义视图，否则视图是不起作用的，因此 Django 框架知道当它收到用户的请求时要调用什么视图函数。

添加功能

首先，我们需要知道我们是否可以为子网提供“添加 DHCP 网络”功能。最简单、最合理的方法是查看网络显示视图，查看是否有任何地址条目的子网大小未设置为 32 位。如果存在子网大小不是 32 位的条目，则该子网不能启用 DHCP 否则，我们可以提供一个到 DHCP add 函数的链接。因此，网络视图将执行检查并传递一个布尔变量，我们将在模板中查询该变量，它将显示一条消息或提供一个链接。下面是视图代码中的快速检查:

```py
for address in addr_list:
    if address.network_size != 32:
        has_subnets = True
```

以及对模板的补充:

```py
<h3><a href="add/">Add new subnet or node IP</a></h3>
<h3>{% if has_subnets %}
DHCP support cannot be enabled for networks with subnets
{% else %}
<a href="dhcp/add/">Enable DHCP support</a>
{% endif %}
</h3>
```

你能看到产生的 URL 是什么吗？该结构遵循我们之前定义的 URL 的相同约定:

```py
http://www.example.com/<application>/<model>/<object>/<action>/
```

到目前为止，对象是一对 IP 地址和它们的网络大小，它们唯一地标识了数据库中的每个对象。现在，对象是物理网络中的 DHCP 网络。DHCP 网络本身没有唯一标识它的东西。因此，让我们将/dhcp/添加到 IP/网络大小对中，这告诉我们这是这个特定网络的 dhcp 对象。假设用于添加 DHCP 网络的新视图名为 add_dhcp，这是需要添加到 URL 映射文件中的内容:

```py
(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/
dhcp/add/$', 'add_dhcp'),
```

这个视图将遵循相同的表单处理模式，它看起来非常类似于我们用来添加新网络的视图。它还要求 form 类为模板自动生成一个表单模型:

```py
class DHCPNetworkAddForm(ModelForm):
    class Meta:
        model = DHCPNetwork
        exclude = ('physical_net',)
```

我们排除物理网络字段，因为它在创建时已经是已知的；它是作为 URL 参数提供的。清单 4-2 展示了我们的 dhcp_add 函数，其中我们甚至使用了之前使用过的相同模板。

***清单 4-2*** 。处理 DHCP 网络添加功能的视图

```py
def add_dhcp(request, address=None):
    if request.method == 'POST':
        network_addr = None
        if address:
            ip, net_size = address.split('/')
            network_addr = NetworkAddress.objects.get(address=ip,
                                                      network_size=int(net_size))
        dhcp_net = DHCPNetwork(physical_net=network_addr)
        form = DHCPNetworkAddForm(request.POST, instance=dhcp_net)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect("../..")
    else:
        form = DHCPNetworkAddForm()
    return render_to_response('add.html',
                              {'form': form,},
                              context_instance=RequestContext(request))
```

您可能想知道 DNS 和域名域发生了什么变化；它们是模型定义中的外键，那么用户应该在这里输入什么呢？在图 4-1 中，你可以看到 Django 将要显示的内容。

![9781484202180_Fig04-01.jpg](img/00025.jpeg)

图 4-1 。呈现的 DHCP 添加表单

Django 引擎足够聪明，能够判断出您希望为用户提供相关表中的对象选择，因此它生成了所有对象的下拉列表！这真的很聪明，它节省了你大量的编码。因此，您需要做的就是输入路由器详细信息，从列表中选择 DNS 服务器和域名，然后单击 Add 按钮。您可以通过转到管理界面并选择 DHCP Networks 视图来验证记录是否已成功创建。

尝试浏览并为其他网络启用 DHCP 支持。请注意，当您向上浏览地址树时，将不会向您提供启用 DHCP 的选项。

此时，我们还需要修改网络的显示模板，以便显示网络的 DHCP 设置的详细信息，并提供修改和删除设置的链接。

修改功能

修改视图功能与添加功能非常相似,除了不是为初始视图创建一个空表单，而是检索现有数据并显示在表单中。所以在清单 4-3 中，我们首先搜索一个现有的 DHCP 网络对象，然后将它传递给 form 类。

***清单 4-3*** 。处理 DHCP 网络修改功能的视图

```py
def modify_dhcp(request, address=None):
    ip, net_size = address.split('/')
    network_addr = NetworkAddress.objects.get(address=ip, network_size=int(net_size))
    dhcp_net = DHCPNetwork.objects.get(physical_net=network_addr)
    if request.method == 'POST':
        # submiting changes
        form = DHCPNetworkAddForm(request.POST, instance=dhcp_net)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect("../..")
    else:
        # first time display
        form = DHCPNetworkAddForm(instance=dhcp_net)
    return render_to_response('add.html',
                              {'form': form,},
                              context_instance=RequestContext(request))
```

删除功能

这是一个简单的函数，搜索 DHCP 网络对象并删除它。目前，我们还没有定义任何相关的数据结构，比如 DHCP 池或规则，但是值得一提的是，所有相关的对象也会被自动删除。

使用地址池扩展 DHCP 配置

到目前为止，我们已经有了不错的代码来处理通用的 DHCP 子网信息，比如路由器、DNS 和域服务器地址。如果您需要任何额外的字段，您可以通过修改 DHCP 网络数据模型类，添加新的字段实例来轻松添加它们。您可能已经注意到，没有一个视图函数直接引用模型字段。Django 框架会自动处理新条目的添加。模板解析器将选择它们并相应地生成输入字段。

现在我们将进行第二次迭代，我们将添加对地址池数据的支持。如您所知，地址池是子网内的一个地址范围，可以根据客户端的类别分配给一组特定的客户端。例如，C 类子网有 254 个可分配给节点的可用地址。然后，我们可以指示 DHCP 服务器将前 10 个地址分配给主机名以 server 开头的主机；另外 10 个将用于请求太阳微系统公司的机器；等等。

地址池数据模型

典型的地址池允许定义特定于地址池的附加 DHCP 选项。例如，您可能希望增加某些池上的 DHCP 租用时间。并非所有服务器都需要短期 DHCP 地址，因此您需要增加这些服务器在池中的租用时间。或者您可能希望所有工作站使用不同的 DNS 服务器。在这个例子中，我们不允许任何额外的选项。因此，模型类看起来相对简单，只包含三个字段:指向其父 DHCP 网络对象的指针和两个边界地址。清单 4-4 显示了代码。

***清单 4-4*** 。DHCP 池数据模型类

```py
class DHCPAddressPool(models.Model):
    DHCPNetwork = models.ForeignKey(DHCPNetwork)
    range_start  = models.IPAddressField()
    range_finish = models.IPAddressField()
```

一旦将它添加到 models.py 中，其中还需要定义表单模型类，在 admins.py 文件中创建适当的记录，并运行 syncdb 命令，Django 将在数据库中创建一个表。请查看第三章中的“定义数据库模型”部分，了解详细说明。

DHCP 网络详细信息

作为第一个工作流，也是查看功能，我们将定义 DHCP 网络查看功能。我们已经在物理网络列表页面上显示了一些通用信息，但现在我们将会有更多与 DHCP 配置相关的项目，所以最好将它们显示在单独的页面上。本页将包含有关地址池和静态 IP 分配规则以及分类规则的信息。到目前为止，您应该对添加新视图相当熟悉了，并且您应该知道这涉及三个步骤:向 urls.py 文件添加 URL-to-view 映射函数规则；定义视图函数，并为视图创建模板。

下面是我们将用来调用 DHCP 显示视图的 URL 映射规则:

```py
(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/dhcp/$',
 'display_dhcp'),
```

对于 DHCP 显示视图，我们引入了两个新函数:一个从 URL 编码的 IP/network_size 对中获取地址对象，另一个从相同的数据中获取 DHCP 网络对象。由于大多数函数需要执行这些操作，现在是时候将它们分开了，如清单 4-5 所示。

***清单 4-5*** 。DHCP 池显示视图和助手功能

```py
def display_dhcp(request, address=None):
    dhcp_net = get_dhcp_object_from_address(address)
    dhcp_pools = DHCPAddressPool.objects.filter(dhcp_network=dhcp_net)
    return render_to_response('display_dhcp.html', {'dhcp_net': dhcp_net,
                                                    'dhcp_pools': dhcp_pools,})

def get_network_object_from_address(address):
    ip, net_size = address.split('/')
    return NetworkAddress.objects.get(address=ip, network_size=int(net_size))

def get_dhcp_object_from_address(address):
    return DHCPNetwork.objects.get(physical_net=get_network_object_from_address(address))
```

DHCP 详细信息页面(清单 4-6 )显示了 DHCP 网络的基本信息，还列出了所有可用的池(如果它们已定义)。

***清单 4-6*** 。DHCP 详细信息显示页面

```py
<h1> DHCP details for {{ dhcp_net.physical_net.address }}/{{ dhcp_net.physical_net.network_size }} network</h1>
<h2><a href="../">Go back to network details</a></h2>
<ul>
<li>Router: {{ dhcp_net.router }}
<li>DNS: {{ dhcp_net.dns_server }}
<li>Domain: {{ dhcp_net.domain_name }}
</ul>
<p>( <a href="modify/">modify</a> | <a href="delete/">delete</a> )</p>
{% if dhcp_pools %}
<p>
<h3>Following DHCP pools are available:</h3>
<ul>
{% for pool in dhcp_pools %}
<li>{{ pool.range_start }} - {{ pool.range_finish }}
( <a href="../dhcp_pool/{{ pool.range_start }}/{{ pool.range_finish }}/delete/">delete</a> )
</li>
{% endfor %}
</ul>
</p>
{% else %}
<h3>There are no DHCP pools defined</h3>
{% endif %}
<p>
( <a href="../dhcp_pool/add/">add new pool</a> )
</p>
```

同样，这是另一个非常标准的视图模板；然而，有几件事值得一提。首先，模板解析器非常智能，它允许您从作为参数传递给模板的对象中引用相关对象。如您所见，我们不直接传递物理网络对象—只传递 DHCP 网络对象；但是因为 DHCP 网络有一个引用其“父”对象的外键，所以我们可以简单地说 dhcp_net.physical_net.address，Django 模板引擎将找到要显示的正确信息。

您可能已经注意到的另一件事是到 Delete 函数的链接。URL 的对象部分变得相当长，被定义为

```py
<network_address>/<network_size>/dhcp_pool/<range_start>/<range_finish>
```

严格地从数据建模的角度来看，这个键包含冗余信息，因为具有给定范围地址的 DHCP 地址池只能属于一个物理网络；因此，不需要在 URL 中指定网络地址。然而，因为我们在所有的模板中都使用了相对 URL，所以在这里包含它也容易得多。这是一个很好的例子，说明严格的规则有时需要妥协，以在代码的其他领域实现更高的效率和简单性。

添加和删除功能

添加和删除在结构和功能上与物理网络和 DHCP 网络视图中的等效功能几乎相同。Add 函数重用相同的 add.html 模板，而 Delete 函数则引用 DHCPAddressPool。

修改 URL 结构

我喜欢从错误中学习，因为我认为这是最有效的学习方法。显然，从别人的错误中学习更好。所以我故意引入了一些不是真正的错误，但可以被称为设计中的缺陷的东西，我把它留到了这一章的这一点上。

如果你已经仔细阅读了所有的代码示例，你一定已经注意到了一件事:尽管我们的代码在功能上是完美的，但感觉就是不对。猜到了吗？继续，再看一下所有模板和视图函数的例子。你在那里注意到了什么普遍现象？

没错。我们已经在模板和视图函数中使用了相对 URL。这是一个非常简单的技巧，而且在大多数时候都非常有效，尤其是在小项目中。它甚至适用于分离的应用，因为当您使用相对路径时，地址解析从另一端有效地工作，与应用 URL 的起始深度无关。

问题是，有这么多的类模型和函数，记住每个模型的 URL 的结构变得相当困难。我们已经设置了关于格式化 URL 的严格规则(记住，总是<模型> / <对象> / <方法>)，并且使用有限数量的方法(到目前为止只有添加、删除、修改和隐式显示)，我们很容易应付。然而，随着模型和 URL 数量的增加，管理和维护所有的 URL 变得更加困难。为什么你需要改变 URL 结构？原因有很多:重组站点、在层次结构中添加新的应用，或者仅仅是修复开发过程中的一个错误。

当我们谈论改变 URL 结构时，我现在需要提到我让另一个“bug”悄悄进来了。还记得我们说过的 <model>/ <object>/ <method>的 URL 结构吗？同样，我在引用 DHCP 网络和 DHCP 池模型时总是在开头使用 networkaddress/我应该做的是分别使用 dhcpnetwork 和 dhcpaddresspool 前缀。</method></object></model>

现在我们有了一个真正有效的理由来返工或修复代码，我们应该如何处理它呢？如果有一种工具或功能允许您获得任何想要链接的对象的 URL，那将是理想的。

模型类中 URL 的生成

Django 框架允许您为每个模型定义一个额外的方法来返回对象的绝对 URL。例如，我们可以这样为网络地址类定义这个方法:

```py
def get_absolute_url(self):
    return '/networkaddress/%s/%s/' % (self.address, self.network_size)
```

有了这个定义，我们就可以在所有模板中使用这个函数来获取对象的 URL:

```py
<a href="{{ address.get_absolute_url }}">{{ address }}</a>
```

这允许我们引用对象 URL，而不用考虑 URL 结构。我们需要的只是一个对 URL 的引用，我们通过引用对象的 get_absolute_url 属性来获取该值。如果出于某种原因，我们决定改变 URL 结构，我们将不需要修改任何模板代码，因为引用是在它之外生成的。

URL 的反向解析

这种方法仍然存在一个问题；如果您还记得，URL 现在将在两个位置定义:URL 配置文件和模型定义。因此，即使我们不需要重新访问整套模板和视图函数，我们仍然需要确保 get_absolute_url 返回的任何内容也在 URLConfig 文件中定义。

Django 对这个问题也有一个解决方案:您可以使用 permalink decorator(decorator 是一个修改它所修饰的函数的行为的类)进一步将您的模型从 URLConfig 文件中分离出来。您需要将视图方法名和视图方法参数(作为列表或字典)传递给装饰器，然后它会为您计算出匹配的 URL。让我们看看这个例子:

```py
@models.permalink
def get_absolute_url(self):
    return ('views.networkaddress_display', (),
            {'address': '%s/%s' % (self.address, self.network_size)})
```

这里我们没有使用参数列表，但是因为它是必需的，所以我们只传递一个空列表。我的偏好是使用字典来传递 URL 中使用的所有参数，因此我们不需要记住每个变量的数量和位置。

让我提醒您这个视图的 URL 配置是什么样子的:

```py
(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/$', views.networkaddress_display),
```

给定这个组合(视图函数和参数)，permalink 将找到匹配的 URL 并返回它。

不过，这里有一个陷阱。有些情况下，装饰者不能唯一地识别匹配的 URL:

```py
(r'^networkaddress/$', views.networkaddress_display),
(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/$',
                                                 views.networkaddress_display),
```

将名称分配给 URL 模式

在这种情况下，有两个 URL 调用同一个视图函数，所以反向 URL 匹配器(试图从视图名中找到匹配的 URL)会被弄糊涂，因为不止一个 URL 指向同一个视图。

如果是这种情况，您可以为您的 URL 模式指定名称，以便它们都可以被唯一地识别:

```py
url(r'^networkaddress/$', views.networkaddress_display,
name='networkaddress-displaytop'),
url(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/$',
                      views.networkaddress_display, name='networkaddress-display'),
```

现在，即使两种 URL 模式调用相同的函数，也可以使用它们唯一的名称单独引用它们。

最后，下面是模型类将如何解析其对象的 URL:

```py
@models.permalink
def get_absolute_url(self):
    return ('networkaddress-display', (),
            {'address': '%s/%s' % (self.address, self.network_size)})
```

模板中 URL 引用的使用

显然，模型代码只能为每个对象返回一个 URL。这样的模型类对应用的功能没有可见性；它仅设计用于表示应用操作的数据。所以通常模型实例会返回用于显示对象的 URL——换句话说，一个*表示 URL* 。

在我们的应用中，我们有多个与数据实体相关联的函数，比如添加、删除和修改。因为我们有一个定义良好的 url 结构，并且所有动作“关键字”都附加在末尾，所以我们可以在对象上使用 get_absolute_url 来获取它的基本 URL，然后在模板中附加动作词。但是这种方法不合适，因为 URL 信息将包含在 URLConfig 和使用它的每个模板中。

在前面的示例中，我们在模板中使用了{{ object.get_absolute_url }}结构来引用 url。Django 还有一个 URL 解析器模板标签，它能够通过名称引用 URL。然后，您需要向它传递一个参数，以便它能够匹配并生成所需的 URL:

```py
{% url "networkaddress-display" address %}
```

清单 4-7 显示了如何使用 URL 标签的一个更详细的例子。

***清单 4-7*** 。URL 解析器模板标记的示例

```py
{% if addresses_list %}
    <ul>
    {% for address in addresses_list %}
        <li><a href="{% url 'networkaddress-display' address %}">
                    {{ address.address }}/{{ address.network_size }}</a>
            {% ifequal address.network_size 32 %}(host){% else %}(network){% endifequal %}
            {{ address.description }}
            (<a href="{% url 'networkaddress-delete' address %}">delete</a> |
            <a href="{% url 'networkaddress-modify' address %}">modify</a>)
        </li>
    {% endfor %}
    </ul>
{% else %}
    {% ifequal parent.network_size 32 %}
        This is a node IP
        <ul>
        <li>Description: {{ parent.description }}
            ( <a href="{% url 'networkaddress-modify' parent %}">modify</a> )</li>
        </ul>
    {% else %}
        No addresses or subnets in this range
    {% endifequal %}
{% endif %}
```

所有的 URL 模式名称都在 URLConfig 文件中定义，如清单 4-8 所示。

***清单 4-8*** 。网络地址 URL 模式

```py
urlpatterns = patterns('',
   url(r'^networkaddress/$', views.networkaddress_display,
        name='networkaddress-displaytop'),
   url(r'^networkaddress/add/$', views.networkaddress_add,
        name='networkaddress-addtop'),
   url(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/$',
        views.networkaddress_display, name='networkaddress-display'),
url(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/
       delete/$', views.networkaddress_delete, name='networkaddress-delete'),

url(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/
       add/$', views.networkaddress_add, name='networkaddress-add'),

url(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})/
       modify/$', views.networkaddress_modify, name='networkaddress-modify'),
```

最后，所有的 URL 都被分离并定义在一个位置 URLConfig 文件。每当您选择更改它们时，您只需要在一个地方这样做，无论是模型、视图还是模板都不需要修改。

添加客户分类

为了充分利用地址池，我们需要具备客户端分类功能。换句话说，我们必须定义一些规则来识别是什么在发送请求，然后从适当的地址池中分配 IP 地址。由于我们没有实现“向导”类型的应用，所有规则都需要是 ISC DHCP 能够理解的格式的纯文本。这对于对配置文件语法知之甚少的人没有帮助，但是对于那些必须管理相当大的 DHCP 配置的人来说，这确实很方便。

对数据模型的补充

新数据模型的类定义相当简单，只包含两个字段:规则文本和描述。我们还需要扩展 Pool 类，以便它引用适当的 Class Rule 对象，如清单 4-9 所示。

***清单 4-9*** 。扩展 DHCP 池模型并引入规则模型

```py
class DHCPAddressPool(models.Model):
    dhcp_network = models.ForeignKey(DHCPNetwork)
    class_rule = models.ForeignKey(ClassRule)
    range_start  = models.IPAddressField()
    range_finish = models.IPAddressField()

    def __unicode__(self):
        return "(%s - %s)" % (self.range_start, self.range_finish)

class ClassRule(models.Model):
    rule = models.TextField()
    description = models.CharField(max_length=400)

    def __unicode__(self):
        return self.id
```

模板继承

由于规则管理将是通用的，我们希望在我们的所有页面中提供到显示和管理页面的链接，这样用户就可以直接跳转到它。到目前为止，我们有两个显示页面来显示物理网络和 DHCP 网络，但将来我们可能会有更多。那么我们如何给所有页面添加一个链接呢？显然，编辑每个页面并不是一个理想的解决方案。

Django 模板管理系统允许模板继承，因此您可以定义一个容器模板，然后在此基础上创建其他模板。基本模板包含占位符，从它继承的每个模板将提供放置在这些占位符中的元素。

这里有一个例子。首先，让我们定义所有其他人将继承的基础模板；清单 4-10 显示了代码。

***清单 4-10*** 。基本模板

```py
{% block menu %}
<ul>
    <li><a href="{% url 'networkaddress-displaytop' %}">Network address management</a></li>
    <li><a href="{% url 'classrule-displaytop' %}">Class rule management</a></li>
</ul>
{% endblock %}
<hr/>
{% block contents %}
{% endblock %}
```

接下来，我们定义两个块:一个菜单块和一个内容块。因为我们的主要目标是分离菜单模板代码并重用它，所以我们不需要将它放在一个单独的块中——但是这样做是一个很好的实践，因为这允许其他模板在需要的时候用其他的东西替换这个菜单。{% block %}标记之外的任何内容都不能从其他模板中访问，因此是不可更改的。标记中包含的任何内容都是默认值，如果继承模板不重写该块，将会显示这些内容。

第二个块用于保存其他显示页面的内容，因此它被留空。继承模板将替换它的内容；可选地，他们也可以覆盖菜单部分。清单 4-11 显示了新的 display.html 模板，它现在继承自 base.html。

***清单 4-11*** 。让 display.html 继承 base.html

```py
{% extends "base.html" %}
{% block contents %}
<contents of the original display.html>
{% endblock %}
```

同样，我们也需要更改 display_dhcp.html。完成后，两个页面都将包含一个通用菜单，允许应用用户在网络配置和类规则配置之间切换。

班规管理

我们将使相同的规则集适用于我们系统中的所有 DHCP 地址池。因此，在我们为任何 DHCP 地址池分配特定规则之前，我们首先需要定义这个规则。我们这样做是为了让用户能够重用现有的规则。如果在许多不同的子网中重复使用相同的规则，这种方法很好。但是，如果您的规则是特定的，并且不太可能被重用，那么这不是最好的方法，因为您最终会得到大量的一次性条目，并且列表很快会变得难以管理。

如果是后者，您可能需要考虑为规则和子网定义类别，以便它们可以自动分组。然后，当您创建一个新的 DHCP 网络时，您可以选择您想要查看的类别。

之前，我们已经为系统中的所有模型创建了添加、修改、删除和显示视图。这似乎是一个重复的过程，你不觉得吗？如果有一种方法可以自动执行像对象的基本创建、修改和删除这样的任务，那就太好了。你猜怎么着？Django 框架提供了这种功能；它被称为*通用视图*。

通用视图

通用视图是对传递给它们的任何对象执行基本和常见任务的视图。Django 附带了四种类型的通用视图:

*   重定向到其他页面或呈现任何给定模板(通常是静态内容)的视图。
*   生成对象列表或显示任何特定对象的详细信息的视图。
*   根据对象的创建日期列出对象的视图。如果你正在创建一个博客或新闻网站，这些会更有用。
*   用于添加、删除和修改对象的视图。

通用视图可以从 django.views.generic 库中导入。通常在 URLConfig 文件中需要它们，因为这是将 URL 映射到视图的地方。你可以在 Django 官方文档中找到每个泛型和基类视图的完整列表和详细描述:[`docs . Django project . com/en/dev/ref/class-based-views/`](https://docs.djangoproject.com/en/dev/ref/class-based-views/)。你会发现有两种类型的类视图:基类和泛型。如果您正在定义自己的视图类，基本视图将用作基础视图，而通用视图可以立即使用。

由于类规则模型的简单性，我们将使用通用视图来管理模型的对象。我们不使用通用视图来管理其他模型的原因是，我们希望在视图所做的事情上留下更多的灵活性。在以后的某个阶段，我们可能想要扩展视图函数来执行额外的检查和任务，这对于一般视图来说是不容易做到的。

对象列表的显示

重要的事情先来。让我们调用一个通用视图来显示所有可用的类规则对象的列表。使用泛型类视图的最佳方式是创建一个从泛型类继承的自定义类，定义一些指定其行为的参数(如模板名、模型类名)，然后在 urls.py 中使用该类。

清单 4-12 中的代码说明了如何定义一个定制的通用视图。这段代码通常放在 views.py 中，与其他视图函数和类放在一起。

***清单 4-12*** 。分类规则查询集

```py
class ClassRuleDisplay(ListView):
    model = ClassRule
    template_name = 'display_classrule.html'
```

这里的模型条目包含我们想要显示的模型类名，template_name 是模板文件的名称。如果我们选择不定义模板的名称，Django 会尝试自动为它生成文件名，并尝试加载一个名为 <application_name>/ <model_name>_list.html 的文件。我们选择指定模板名称，这样就少了一件担心事情不正常的事情。</model_name></application_name>

我们还需要添加 URL 到视图的映射，就像您在前面几节中对所有其他视图所做的那样。但是，这一次我们将使用一个通用视图 list_detail.object_list，并向它传递包含通用视图所需的所有信息的 queryset 对象:

```py
url(r'^classrule/$', views.ClassRuleDisplay.as_view(), name='classrule_displaytop'),
```

最后，我们需要创建一个模板来很好地显示所有的对象。我们已经添加了到细节、修改和删除函数的链接，我们将在下一节中定义这些函数，所以代码看起来像清单 4-13 中的。

***清单 4-13*** 。类别规则列表模板

```py
{% extends "base.html" %}
{% block contents %}
<h1>List of all Class Rules</h1>
{% if object_list %}
    <ul>
    {% for rule in object_list %}
        <li>{{ rule.description }}
                ( <a href="{% url 'classrule_display' rule.id %}">details</a> |
                  <a href="{% url 'classrule_modify' rule.id %}">modify</a> |
                  <a href="{% url 'classrule_delete' rule.id %}">delete</a> )</li>
    {% endfor %}
    </ul>
{% else %}
No class rules defined yet.
{% endif %}
<h3><a href="{% url classrule_add %}">Add new rule</a></h3>
{% endblock %}
```

这是快速显示任何一组对象列表的一种简单得多的方式，并且不需要您编写一行视图代码。

对象的详细视图

类似地，我们将使用通用视图来显示任何。特定的类规则对象。这里唯一的区别是，我们需要向通用视图传递一个特定的对象 ID，以便视图代码可以从列表中选择适当的对象。

我们必须定义一个新的定制视图类，它继承自 Django 的一个内置泛型类:

```py
class ClassRuleDetailDisplay(DetailView):

    queryset = ClassRule.objects.all()
    template_name = 'display_classrule.html'

    def get_object(self):
        object = super(ClassRuleDetailDisplay, self).get_object()
        return object
```

在 list 类中，我们为 Django 提供了模型名称。这里，我们必须创建一个 queryset 对象，这在大多数情况下就足够了。我还覆盖了 get_object 方法，调用该方法来检索单个对象。在我们的例子中，我们不需要这样做，因为默认的实现已经足够了。事实上，如你所见，我们在这里所做的只是调用父方法的实现。但是您可以在这里添加额外功能，比如从不同的对象获取额外的数据，或者在访问这个对象时更新另一个模型中的字段。

新的 URL 规则将如下所示；它包含对 pk(或“主键”)的引用，告诉通用视图需要将哪个对象传递给模板:

```py
url(r'^classrule/(?P<pk>\d+)/$', views.ClassRuleDetailDisplay.as_view(), name='classrule_display'),
```

最后，让我们更新模板的版本，如清单 4-14 所示。它现在检查对象是否包含任何内容，在这种情况下，它显示关于它的详细信息；否则，它将显示一个类规则列表。

***清单 4-14*** 。显示列表和对象详细信息的更新视图

```py
{% extends "base.html" %}
{% block contents %}
{% if object %}
    <h1>Class Rules details</h1>
    <ul>
        <li>ID: {{ object.id }}</li>
        <li>Description: {{ object.description }}</li>
        <li>Rule text:
            <pre>
                {{ object.rule }}
            </pre>
        </li>
    </ul>
    ( <a href="{% url 'classrule-modify' object.id %}">modify</a> |
      <a href="{% url 'classrule-delete' object.id %}">delete</a> )
{% else %}
    <h1>List of all Class Rules</h1>
    {% if object_list %}
        <ul>
        {% for rule in object_list %}
            <li>{{ rule.description }}
                   ( <a href="{% url 'classrule-display' rule.id %}">details</a> |
                     <a href="{% url 'classrule-modify' rule.id %}">modify</a> |
                     <a href="{% url 'classrule-delete' rule.id %}">delete</a> )</li>
        {% endfor %}
        </ul>
    {% else %}
        No class rules defined yet.
    {% endif %}
    <h3><a href="{% url 'classrule-add' %}">Add new rule</a></h3>
{% endif %}
{% endblock %}
```

![Image](img/00010.jpeg) **注意**默认情况下，模板对象名称是 object。通用列表视图将 _list 附加到该名称上。因此，在详细视图中，您将收到作为单个对象实例的 object 或作为对象列表的 object_list。通过在 queryset 字典中将 context_object_name 设置为您喜欢的任何名称，您可以随时更改模板名称。

添加或修改的新对象

使用通用视图添加对象也同样简单。您需要通过从通用视图类继承来为其提供基本信息，并为这些动作定义 URL 模式。通用视图需要以下信息:

*   模型类名，因此视图知道它正在处理哪种类型的对象。
*   模型表单类，所以表单生成框架知道如何生成表单表示。
*   动作后重定向 URL，它告诉视图在数据提交后将用户重定向到哪里。这应该是一个表示 URL 的字符串。如果没有指定，Django 会尝试对对象应用 get_absolute_url，所以要确保定义了对象的 get_absolute_url 方法。然而，使用 get_absolute_url 的优点是，如果修改 url，不需要在两个地方更改它。

在清单 4-15 中，我们定义了两个类；一个是模型类，一个是模型表单类。严格地说，这里不需要 Model Form 类，因为我们有一个只有两个字段的非常简单的模型，但是我更喜欢显式地定义它们；如果我想在以后扩展和修改模型，这就更容易了。注意 get_absolute_url 返回反向解析的 url。这些修改应该在 models.py 文件中完成:

***清单 4-15*** 。类规则模型和表单类

```py
class ClassRule(models.Model):
    rule = models.TextField()
    description = models.CharField(max_length=400)

    def __unicode__(self):
        return self.description[:20]

    @models.permalink
    def get_absolute_url(self):
        return ('classrule_display', (), {'object_id': self.id})

class ClassRuleForm(ModelForm):
    class Meta:
        model = ClassRule
```

在 views.py 中，我们定义了两个继承自通用视图的类:一个用于添加新条目，另一个用于更新现有记录。注意，更新类需要知道模型类。它使用这个类来查找数据库中的相关对象，所以当您单击修改链接时，表单将预加载现有数据。

```py
class ClassRuleCreate(CreateView):
    form_class = ClassRuleForm
    template_name = 'add.html'

class ClassRuleUpdate(UpdateView):
    model = ClassRule
    form_class = ClassRuleForm
    template_name = 'add.html'
```

我们甚至可以重用我们用来添加或修改其他对象的表单。因为我们保持了表单的通用性，并让模板处理程序生成所有必需的字段集，所以它不需要任何更改。

最后，让我们为 add 和 Modify 函数添加两个 URL 模式，并确保使用与模板中引用的相同的 URL 模式名称:

```py
url(r'^classrule/(?P<pk>\d+)/modify/$', views.ClassRuleUpdate.as_view(), name='classrule_modify'),
url(r'^classrule/add/$', views.ClassRuleCreate.as_view(), name='classrule_add'),
```

对象的删除

删除对象包括一个中间步骤:要求用户确认操作。这是在一般的 delete 视图中通过使用简单的逻辑实现的——如果 HTTP 请求是 GET，则意味着用户单击了删除链接，因此需要显示确认页面(该页面指向同一个 URL)。如果 HTTP 请求是 POST，这意味着用户单击了 Confirm 按钮，并且表单已经通过 HTTP POST 调用提交，在这种情况下，视图将继续删除对象。

通用删除视图有一个警告。它需要一个删除后的 URL 换句话说，它需要知道在对象被删除后将用户带到哪里。显而易见的解决方案是反向查找 URL 并使用它。

***清单 4-16*** 。基于通用类视图的自定义删除视图

```py
class ClassRuleDelete(DeleteView):
    model = ClassRule
    success_url = reverse_lazy('classrule_displaytop')
    template_name = 'delete_confirm_classrule.html'
```

确认模板只是要求确认并将数据重新提交到同一个 URL，但是现在使用 HTTP POST 方法:

```py
<form method="post" action=".">
<p>Are you sure?</p>
<input type="submit" />
</form>
```

最后，我们向 URL 模式列表添加了另一项内容:

```py
url(r'^classrule/(?P<pk>\d+)/delete/$', views.ClassRuleDelete.as_view(), name='classrule_delete'),
```

![Image](img/00010.jpeg) **注意**正如您可能已经猜到的，修改和删除视图不仅需要了解它们所操作的对象的类型，还必须唯一地标识它们所修改或删除的对象。对象 ID 作为 pk 变量从 URL 模式传递给它们。

生成 DHCP 配置文件

我们已经得到了我们需要的所有信息，但就目前的形式来看，这些信息没有多大用处。所有数据都在数据库表中，尽管它详细说明了 DHCP 服务器应该如何配置，但它不能以这种形式使用。我们需要编写一个视图来生成 DHCP 服务器能够理解的配置文件。

让我们回过头来重新看看 DHCP 配置文件应该是什么样子。因为我们使用的是 ISC DHCP 服务器，所以配置文件(仅包括我们感兴趣的元素)具有以下结构:

```py
<dhcpd configuration items or generic DHCP options>

<class definitions>

<network definition>
    <subnet definition>
        <subnet options>
        <pool definitions>
```

让我们将这个配置文件作为 web 资源提供。因此，我们需要以与生成用户界面页面类似的方式来处理它:我们需要定义一个视图，该视图提供数据以及在页面上展示这些数据的模板——在本例中，是一个纯文本文档。

我们从视图开始，如清单 4-17 所示。

***清单 4-17*** 。为 DHCP 配置文件收集数据的视图

```py
def dhcpd_conf_generate(request):
    class_rules = ClassRule.objects.all()
    networks = []
    for net in DHCPNetwork.objects.all():
        networks.append( { 'dhcp_net': net,
                           'pools': DHCPAddressPool.objects.filter(dhcp_network=net),
                         } )

    return render_to_response('dhcpd.conf.txt',
                              {'class_rules': class_rules,
                               'networks': networks,
                              },
                              mimetype='text/plain')
```

我们不在数据库中保存 DHCP 服务器配置项；因此，我们将把它们直接放入模板中。类规则简单地列在任何其他结构之外，所以我们生成系统上所有类规则的列表，并将其作为列表传递。

每个 DHCP 子网可能在其范围内定义了几个不同的 DHCP 地址池，因此这些地址池只需要出现在特定的 DHCP 地址池定义中。因此，我们遍历所有可用的 DHCP 网络，并生成一个包含以下内容的列表:

*   DHCP 地址对象
*   与给定 DHCP 网络相关的所有 DHCP 池的列表

最后，我们告诉 Django 将文档的 MIME 类型改为“text/plain”。如果我们只是要下载它，这没多大关系。但是，如果您尝试在 web 浏览器中打开这个文件，您会看到整个文档显示在一行上，因为 web 浏览器会认为它是一个有效的 HTML 文档。因此，为了在浏览器中查看时保留格式，我们需要对响应进行格式化，以表明文档是一个平面文本文件。

最后，在清单 4-18 中，我们有一个模板，它把所有的数据放在一个可以被 DHCP 服务器使用的结构中。

***清单 4-18*** 。DHCP 配置文件的模板

```py
 1 {% autoescape off %}
 2 ignore client-updates;
 3 ddns-update-style interim;
 4
 5 {% if class_rules %}
 6     {% for cr in class_rules %}
 7         # {{cr.description }}
 8         class "class_rule_{{ cr.id }}" {
 9             {{ cr.rule }};
10         }
11     {% endfor %}
12 {% endif %}
13
14 {% if networks %}
15     {% for net in networks %}
16         shared-network network_{{ net.dhcp_net.id }} {
17             subnet {{ net.dhcp_net.physical_net.address }} netmask {{                net.dhcp_net.physical_net.get_netmask }} {
18                 option routers {{ net.dhcp_net.router }};
19                 option domain-name-servers {{ net.dhcp_net.dns_server.address }};
20                 option domain-name {{ net.dhcp_net.domain_name.name }};
21
22                 {% if net.pools %}
23                     {% for pool in net.pools %}
24                         pool {
25                             allow members of "class_rule_{{ pool.class_rule.id }}";
26                             range {{ pool.range_start }} {{ pool.range_finish }};
27                         }
28                     {% endfor %}
29                 {% endif %}
30             }
31         }
32     {% endfor %}
33 {% endif %}
34
35 {% endautoescape %}
```

现在让我们更详细地看一些行。

*   *Line 1*:Django 模板引擎有一个内置的文本转义功能，可以将所有不符合 HTML 的字符转换成 HTML 代码表示。例如，字符(")将被替换为&quot；字符串。因为我们提供的是平面文本文档，所以我们需要用原始符号表示所有字符，而不是 HTML 编码。所以我们关闭了 autoescape 功能，默认情况下它是打开的。
*   *第 2–3 行*:这些只是标准的 DHCP 服务器配置项目，您可能希望将其替换为适合您环境的项目。
*   *第 5–12 行*:查看 class_rules 列表是否为空的简单检查，随后是遍历所有元素并显示它们的循环。
*   *第 14–15 行*:再次检查网络列表是否为空，然后是循环语句。
*   *第 17 行*:这里你可以看到我们是如何引用相关对象的。我们没有将任何关于物理网络的信息直接传递给模板，但是我们仍然可以通过 DHCP 网络对象访问它，该对象有一个指向相关物理网络对象的外键。只要这种关系是明确的(一个 DHCP 网络只能属于一个物理网络)，就可以使用这种语法来访问相关信息。
*   类似地，我们正在访问相关的路由器和 DNS 对象。
*   *第 22–23 行*:检查 DHCP 网络是否有可用的地址池，如果有，就遍历这些地址池。
*   *第 25–26 行*:注意，我们是根据类名和网络名的对象 id 来生成它们的。这是确保名称唯一的最简单方法，也可用于在配置文件中进行交叉引用。

您可能已经注意到，我们正在使用物理网络对象的 get_netmask 属性。这个字段不存在，那么它是什么？DHCP 服务器希望子网被定义为由基本网络地址和网络掩码组成的对。我们在模型中没有网络掩码字段，但从网络大小中推导出来非常简单，网络大小用位数表示；清单 4-19 显示了代码。

***清单 4-19*** 。根据网络大小计算网络掩码

```py
def get_netmask(self):
    bit_netmask = 0;
    bit_netmask = pow(2, self.network_size) - 1
    bit_netmask = bit_netmask << (32 - self.network_size)
    nmask_array = []
    for c in range(4):
        dec = bit_netmask & 255
        bit_netmask = bit_netmask >> 8
        nmask_array.insert(0, str(dec))
    return ".".join(nmask_array)
```

这个函数的逻辑非常简单:

*   将整数变量中的位数设置为 1(即设置为 1)。这可以表示为 2^ <number of="" bits="">-1。</number>
*   将结果左移，用 0 填充剩余的位数。网络掩码中的总位数总是 32。
*   每 8 位(共 4 组)，转换成十进制数串。
*   连接所有数字，使用点符号分隔各个数字。

最后，我们需要添加一个额外的 URL 模式来调用这个视图:

```py
url(r'^dhcpd.conf/$', views.dhcpd_conf_generate, name='dhcp-conf-generate')
```

下面是一个 DHCP 配置文件的例子，它是由我输入到数据库中的一些样本数据生成的:

```py
ignore client-updates;
ddns-update-style interim;
        # class rule 1
        class "class_rule_1" {
            match if substring (option host-name, 0, 6) = "server";;
        }
        # test rule (gen form)
        class "class_rule_2" {
            test rule - gen form;
        }

        shared-network network_4 {
            subnet 192.168.0.128 netmask 255.255.255.128 {
                option routers 192.168.0.130;
                option domain-name-servers 208.67.222.222;
                option domain-name domain1.example.com;
            }
        }
        shared-network network_5 {
            subnet 192.168.0.0 netmask 255.255.255.128 {
                option routers 192.168.0.113;
                option domain-name-servers 208.67.220.220;
                option domain-name domain2.example.com;
                        pool {
                            allow members of "class_rule_1";
                            range 192.168.0.1 192.168.0.20;
                        }
                }
        }
```

其他修改

大部分工作已经完成，但是我们仍然需要添加一些东西来满足最初的需求:节点 IP 的主机名解析和状态检查。

将 IP 解析为主机名

为了获得关于 IP 地址的更多信息，让我们做一个反向的域名解析，在每个地址条目旁边打印一个完全限定的域名。我们可以在两个地方实现这种查找:我们可以修改显示视图并在那里进行主机查找，然后将信息传递给模板；或者，我们可以用一个额外的函数来扩展模型类，该函数返回 IP 地址的主机名，如果主机名无法解析，则返回一个空字符串。

让我们选择第二个选项，因为它更优雅，并且不需要改变视图和模板之间的接口。这里有一个模型类的附加方法，它使用 Python 的套接字库中的 gethostbyaddr 函数来执行反向查找。结果是一个元组:(<hostname>，<zone>，</zone></hostname>

<address>)，我们使用第一个条目(主机名)作为结果。</address>

```py
import socket

...
class NetworkAddress(models.Model):
...
    def get_hostname(self):
        try:
            fqdn = socket.gethostbyaddr(str(self.address))[0]
        except:
            fqdn = ''
        return fqdn
```

以及模板中的一个小变化，以显示附加属性(如果可用):

```py
{% for address in addresses_list %}
  <li><a href="{% url networkaddress-display address %}">{{ address.address }}/
                                                         {{ address.network_size }}</a>
    {% ifequal address.network_size 32 %}(host){% else %}(network){% endifequal %}
      {{ address.description }}
      {% if address.get_hostname %} ({{ address.get_hostname }}) {% endif %}
    (<a href="{% url networkaddress-delete address %}">delete</a> |
     <a href="{% url networkaddress-modify address %}">modify</a>)
  </li>
{% endfor %}
```

检查地址是否在使用中

让我们实现一个简单的函数来检查 IP 地址是否在使用中。为此，我们需要向 IP 地址发送 ICMP 回应消息，并等待响应。严格地说，这不是检查地址是否在使用中的有效测试，因为可能有一些情况是 IP 地址被使用了，但是没有响应 ping 请求。例如，防火墙可能阻止 ICMP 通信，或者该通信可能在服务器级别被阻止。然而，在大多数情况下，这个简单的测试是非常有效的；请记住，此测试指示的故障不一定意味着服务器的实际故障或地址未被使用。

实现遵循定义一个视图并将一个新的 URL 模式添加到 URLConfig 文件的常见模式。由于使用 Python 套接字库实现 ICMP 相对复杂(它要求在原始模式下使用套接字，这又要求应用以 root 用户身份运行)，我们将调用系统 ping 工具并根据返回代码做出决定，如清单 4-20 所示。

***清单 4-20*** 。对 IP 地址进行 ICMP 检查的视图

```py
def networkaddress_ping(request, address=None):
    if responding_to_ping(address):
        msg = "Ping OK"
    else:
        msg = "No response"
    return HttpResponse(msg)

def responding_to_ping(address, timeout=1):
    import subprocess
    rc = subprocess.call("ping -c 1 -W %d %s" % (timeout, address),
                         shell=True, stdout=open('/dev/null', 'w'),
                         stderr=subprocess.STDOUT)
    if rc == 0:
        return True
    else:
        return False
```

这里我们强制 ping 只发送一个数据包，超时设置为 1 秒。虽然这可能会降低准确性，但响应会快得多。大多数本地网络应该在这些限制内运行，但是如果您需要更高的准确性，您可以增加默认超时并指示 ping 发送多个探测数据包。

您还需要添加两个额外的 URL 模式:

```py
url(r'^networkaddress/(?P<address>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/ping/$',
    views.networkaddress_ping, name='networkaddress-ping'),
url(r'^networkaddress/$', views.networkaddress_ping,
name='networkaddress-ping-url'),
```

第一个模式捕获一个 IP 地址以及它需要在给定地址上执行的方法(/ping/)。第二行只是用于日常管理——稍后您会发现为什么需要它。

为什么我们将这种检查实现为对 web 服务器的单独调用？生成要显示的 IP 地址列表，逐个 ping 每个地址，然后将 ping 结果和 IP 地址一起传递给模板，不是更容易吗？是的，我们可以这样做，但是这种方法有一个主要问题:应用响应时间。在现实生活中，您可能有非常大的网络，可能需要在数百台服务器上执行 ping 检查。即使您以多线程的方式实现这种检查——换句话说，尝试同时调用 ping 函数——您仍然会花费 1 秒、2 秒甚至更多的时间来完成请求。从可用性的角度来看，这是不可接受的；如果系统反应慢，用户不会喜欢它。

因此，我们在这里要做的是显示子网中所有地址的列表，然后使用 JavaScript 异步调用 ping URL。用户不会立即获得状态报告，但至少会立即显示包含其他信息和操作链接的页面。

这种方法的另一个好处是，您根本不需要对显示视图进行任何更改——只需对显示模板进行一些小的修改(添加一个占位符来保存状态信息)。JavaScript 将被放在基础模板中，因此所有页面都自动获得该功能。

因为这本书不是关于 JavaScript 的，所以我将只限于一个简单的解释和一个如何使用它的例子。清单 4-21 使用 jQuery 库执行异步 AJAX 调用来获得结果并相应地更新网页。

***清单 4-21*** 。修改的地址列表循环代码

```py
{% for address in addresses_list %}
        <li><a href="{% url networkaddress-display address %}">{{ address.address }}/
            {{ address.network_size }}</a>
            {% ifequal address.network_size 32 %}(host){% else %}(network){% endifequal %}
            {{ address.description }}
            {% if address.get_hostname %} ({{ address.get_hostname }}) {% endif %}
            (<a href="{% url networkaddress-delete address %}">delete</a> |
            <a href="{% url networkaddress-modify address %}">modify</a>)
            {% ifequal address.network_size 32 %}
            [Status: <span class="address"
                 id="ip_{{ address.get_formated_address }}">Unknown</span> ]
            {% endifequal %}
        </li>
    {% endfor %}
```

附加行检查地址是否可能是节点 IP，然后插入一个 HTML 标记，它将用于更新文档中该位置的信息。这个标签有两个属性:Class 和 ID。我们将使用 Class 属性来标识哪些标签包含 IP 地址并需要检查，并使用 ID 属性来保存 IP 地址的值。

你可能想知道这个 get_formated_address 方法是什么，为什么我们不直接使用地址。原因是 jQuery 期望 HTML 标签 ID 名称中不能有点，ID 名称也需要以字母开头；因此，我们必须为它添加 ip_ 前缀。此方法只是替换所有出现的(。)和地址字段中的(_)。

最后，我们添加一些 JavaScript 来遍历属于同一个地址类的所有标签，并对 web 服务器执行 AJAX 异步调用。结果将被用作标签的 HTML 内容。清单 4-22 中的代码已经被添加到基础模板中，所有其他模板都继承自基础模板。

***清单 4-22*** 。执行异步调用并更新状态页面的 JavaScript

```py
<html>
<head>
<script type="text/javascript" src "http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.3.2.min.js">
</script>
<script type="text/javascript">
    $(document).ready(function(){
        $(".address").each(function () {
            var curId = $(this).attr('id');
            updateStatus(curId);
        });
    });

    function updateStatus(attrId) {
        address = attrId.replace('ip_', '');
        address = address.replace(/_/g, '.');
        $.ajax({
            url: '{% url networkaddress-ping-url %}' + address + '/ping/',
            success: function(response) {
                $('#' + attrId).html(response);
            }
        });
    }

</script>
</head>
```

现在你明白为什么我们需要占位符 URL 模式了。JavaScript 也部分由 Django 生成——我们使用反向 URL 查找插入网络地址 URL。因为我们不能生成一个完整的 URL(其中包含地址部分)，所以这是一个通用的 URL，它将被 JavaScript 修改。我们只使用它的第一部分；因此，我们需要在 URLConfig 中定义它。

因此，这段 JavaScript 代码的逻辑如下:

*   删除 ip_ 前缀。
*   用点替换下划线。
*   执行 AJAX 异步调用。
*   结果出来后更新网页。

现在，当用户导航到列表页面时，它将立即显示，然后随着结果的可用，逐渐更新每个 IP 地址的状态报告。

动态 DHCP 租约管理

到目前为止，我们的项目是基于我们需要生成一个静态 DHCP 配置文件的假设。到目前为止，我们构建的应用允许我们输入所需的数据，输出是一个配置文件，可以由 ISC DHCP 服务器使用。

这种方法通常已经足够好了，尤其是在 DHCP 配置相当静态的环境中。当您需要频繁地添加和删除静态分配时，问题就出现了。每次修改后，您都必须部署新的配置文件并重启 DHCP 服务器进程。当您重新启动 DHCP 进程时，会有一小段时间 DHCP 服务器不可用。当服务关闭时，所有对 DHCP 地址的请求都将失败，您可能最终会遇到缺少 IP 地址的客户端。

这个问题的解决方案是使用 OMAPI(对象管理应用编程接口)的动态租赁管理。OMAPI 是 ISC DHCP 服务器的 API 接口，它允许您操作服务运行实例的内部数据结构。

在这一节中，我将展示如何使用 OMAPI 操作 DHCP 分配。我们不打算改变到目前为止编写的应用；这只是给出一个如何动态管理 DHCP 租约的想法。

对 OMAPI 采用 Python 接口

我们将使用 Torge Szczepanek 博士的 pypureomapi 库来访问 ISC DHCP OMAPI 接口。该项目可在以下网址获得:[`github.com/CygnusNetworks/pypureomapi`](https://github.com/CygnusNetworks/pypureomapi)如果你想安装它的源代码。

这个包也可以从 PyPI 包库中获得，并且可以用 PIP 工具安装:

```py
# pip install pypureomapi
Downloading/unpacking pypureomapi
  Downloading pypureomapi-0.3.tar.gz
  Running setup.py egg_info for package pypureomapi

Installing collected packages: pypureomapi
  Running setup.py install for pypureomapi

Successfully installed pypureomapi
Cleaning up...
```

设置 ISC DHCP 服务器

ISC DHCP 的默认配置不允许通过 OMAPI 进行管理。如果您想要动态管理服务，您必须创建一个定义身份验证和连接详细信息的附加配置。

让我们从最基本的 ISC DHCP 服务器配置文件开始(在基于 RedHat 的系统上，这个文件是/etc/dhcp/dhcpd.conf)，它包含以下配置:

```py
subnet 192.168.0.0 netmask 255.255.255.0 {

}
```

![Image](img/00010.jpeg) **注意**请记住，在本节中，我们将使用最小的 DHCP 服务器配置，这足以说明 OMAPI 的功能。在现实生活中，您可能希望扩展这种配置，使其符合您的环境要求。

首先，我们需要为将要连接到 ISC DHCP 服务器的用户生成一个 HMAC-MD5 密钥:

```py
# dnssec-keygen -r /dev/urandom -a HMAC-MD5 -b 256 -n USER omapikey
Komapikey.+157+08556
#
```

这将创建两个文件，一个包含密钥，另一个包含元数据信息:

```py
# ls -l Komapikey*
-rw------- 1 root root  70 Jul  6 14:49 Komapikey.+157+08556.key
-rw------- 1 root root 185 Jul  6 14:49 Komapikey.+157+08556.private
#
```

两个文件都包含密钥，在我的例子中是“qkhrf 1 lax E4 cnuaa 2t/go A0 vbfeub 5 ROS+53 ge w2 bzq = ":

```py
# awk '/Key/ {print $2}' Komapikey.+157+08556.private
QKHRF1laxE4cNUAa2t/GOa0VBFeUb5ROS+53gEw2BzQ=
#
```

让我们使用密钥和我们使用的用户名(omapikey ),并更新 ISC DHCP 配置文件:

```py
key omapikey {
  algorithm hmac-md5;
  secret QKHRF1laxE4cNUAa2t/GOa0VBFeUb5ROS+53gEw2BzQ=;
}

omapi-key omapikey;
omapi-port 7911;

subnet 192.168.0.0 netmask 255.255.255.0 {

}
```

当您重新启动 DHCP 服务时，您会看到它现在正在侦听 OMAPI 命令的定义端口:

```py
# netstat -ntlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1330/sshd
tcp        0      0 0.0.0.0:7911            0.0.0.0:*               LISTEN      8994/dhcpd
#
```

添加新的主机租赁记录

在我们开始修改 DHCP 租约记录之前，让我们确保租约文件中没有现有的租约记录。基于 RedHat 的系统上的文件是/var/lib/dhcpd/dhcpd.leases，在这种情况下，其内容如下所示。如您所见，那里没有主机记录:

```py
# cat /var/lib/dhcpd/dhcpd.leases
# The format of this file is documented in the dhcpd.leases(5) manual page.
# This lease file was written by isc-dhcp-4.2.6

server-duid "\000\001\000\001\033L\014\234\010\000'\037\337\302";
#
```

让我们使用 OMAPI 连接到 ISC DHCP，并创建一个新的租用记录:

```py
>>> import pypureomapi
>>> USER='omapikey'
>>> KEY='QKHRF1laxE4cNUAa2t/GOa0VBFeUb5ROS+53gEw2BzQ='
>>> omapi = pypureomapi.Omapi('127.0.0.1', 7911, USER, KEY)
>>> omapi.add_host('192.168.0.100', '00:11:22:33:44:55')
>>>
```

现在，如果您看一下租约文件，您会发现插入了一条新记录:

```py
# cat /var/lib/dhcpd/dhcpd.leases
# The format of this file is documented in the dhcpd.leases(5) manual page.
# This lease file was written by isc-dhcp-4.2.6

server-duid "\000\001\000\001\033L\014\234\010\000'\037\337\302";

host nh53b963617fbd63378fe0 {
  dynamic;
  hardware ethernet 00:11:22:33:44:55;
  fixed-address 192.168.0.100;
}
```

删除主机租赁记录

类似地，您可以从租约数据库中删除主机记录:

```py
>>> import pypureomapi
>>> USER='omapikey'
>>> KEY='QKHRF1laxE4cNUAa2t/GOa0VBFeUb5ROS+53gEw2BzQ='
>>> omapi = pypureomapi.Omapi('127.0.0.1', 7911, USER, KEY)
>>> omapi.del_host('00:11:22:33:44:55')
>>>
```

您将看到租赁记录没有从数据库中删除；相反，它被标记为已删除:

```py
# cat dhcpd.leases
# The format of this file is documented in the dhcpd.leases(5) manual page.
# This lease file was written by isc-dhcp-4.2.6

host nh53b963617fbd63378fe0 {
  dynamic;
  hardware ethernet 00:11:22:33:44:55;
  fixed-address 192.168.0.100;
}
server-duid "\000\001\000\001\033L\014\234\010\000'\037\337\302";

host nh53b963617fbd63378fe0 {
  dynamic;
  deleted;
}
```

摘要

在本章中，我们扩展了网络地址管理应用的功能，增加了对 DHCP 的支持，还执行了一些检查，如 DNS 查找和 ICMP pings，以确保地址在使用中。

*   通用视图有助于减少您需要编写的代码量；使用它们来执行一般任务，如显示对象信息和基本操作，如删除、修改和添加。
*   您可以修改响应 MIME 类型，允许 Django 生成各种各样的内容——HTML、XML、文本，甚至二进制文档。
*   考虑用户体验，以及当数据量增长时，您的应用是否会同样快速地执行各种任务。如果需要，可以使用 JavaScript 推迟内容加载。
*   您不需要有可用的库或编写自己的功能来执行某些任务。如果需要，您可以使用系统工具(如 ping)来执行这些任务。
*   您可以使用 OMAPI 接口来动态更新 ISC DHCP 运行配置。